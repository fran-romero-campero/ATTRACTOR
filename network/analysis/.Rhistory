{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - 24 + hora)/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
}
plot(time.points,var.cosw)
start.time <- 9
end.time <- 1
if(end.time > start.time)
{
factor.hora <- 180/(end.time - start.time)
max.time <- (start.time + end.time)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time && hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
} else
{
day.length <- (24 - start.time) + end.time
factor.hora <- 180/(day.length)
max.time <- start.time + (day.length)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else if(hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - 24 - hora)/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
}
plot(time.points,var.cosw)
start.time <- 9
end.time <- 1
if(end.time > start.time)
{
factor.hora <- 180/(end.time - start.time)
max.time <- (start.time + end.time)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time && hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
} else
{
day.length <- (24 - start.time) + end.time
factor.hora <- 180/(day.length)
max.time <- start.time + (day.length)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else if(hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - (hora+24))/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
}
plot(time.points,var.cosw)
start.time <- 10
end.time <- 2
if(end.time > start.time)
{
factor.hora <- 180/(end.time - start.time)
max.time <- (start.time + end.time)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time && hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
} else
{
day.length <- (24 - start.time) + end.time
factor.hora <- 180/(day.length)
max.time <- start.time + (day.length)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else if(hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - (hora+24))/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
}
plot(time.points,var.cosw)
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/Pedro_de_los_Reyes/arabidopsis_thaliana_clock_network/web_apps/network_visualizer')
runApp('Dropbox/Pedro_de_los_Reyes/arabidopsis_thaliana_clock_network/web_apps/peak_visualizer')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("ChIPseeker", version = "3.8")
BiocManager::install("ChIPseeker", version = "3.8")
BiocManager::install("ChIPseeker", version = "3.8")
library("ChIPSeeker")
BiocManager::install("ChIPseeker", version = "3.8")
library("ChIPSeeker")
library("ChIPseeker")
setwd("~/Dropbox/Ana_Belen_Romero_Losada/medicion_clorofila")
abs.data <- read.table(file="absorbancias_clorofilas.txt",header = TRUE,as.is=TRUE)
head(abs.data)
days <- unique(abs.data$date)
Qs.data <- matrix(0,nrow=length(days),ncol=6)
rownames(Qs.data) <- days
colnames(Qs.data) <- paste0("Q",1:6)
for(i in 1:length(days))
{
current.day <- days[i]
current.day.abs <- subset(abs.data,date == current.day)
current.chl1 <- current.day.abs$V_methanol*current.day.abs$Dil_Fact*(16.5*current.day.abs$A665 - 8.3*current.day.abs$A650)/current.day.abs$V_culture
current.chl2 <- current.day.abs$V_methanol*current.day.abs$Dil_Fact*(33.76*current.day.abs$A650 - 12.5*current.day.abs$A665)/current.day.abs$V_culture
current.chl <- current.chl1 + current.chl2
Qs.mean <- c(mean(current.chl[current.day.abs$Q == "Q1"]), mean(current.chl[current.day.abs$Q == "Q2"]), mean(current.chl[current.day.abs$Q == "Q3"]),
mean(current.chl[current.day.abs$Q == "Q4"]), mean(current.chl[current.day.abs$Q == "Q5"]), mean(current.chl[current.day.abs$Q == "Q6"]))
Qs.sd <- c(sd(current.chl[current.day.abs$Q == "Q1"]), sd(current.chl[current.day.abs$Q == "Q2"]), sd(current.chl[current.day.abs$Q == "Q3"]),
sd(current.chl[current.day.abs$Q == "Q4"]), sd(current.chl[current.day.abs$Q == "Q5"]), sd(current.chl[current.day.abs$Q == "Q6"]))
Qs.data[i,] <- Qs.mean
}
Qs.data
Qs.colours <- rainbow(6)
Date <- as.Date(days,"%d-%m-%Y")
plot(Date, Qs.data[,1],ylim=c(4,16),type="o",col=Qs.colours[1],lwd=2,cex=1.2,pch=ceiling(1/3),ylab="Chlorophyll (ug/ul)",cex.lab=1.3)
for(i in 2:6)
{
lines(Date,Qs.data[,i],type="o",col=Qs.colours[i],lwd=2,cex=1.2,pch=ceiling(i/3))
}
legend("topright",legend=paste("Q",1:6,sep=""),pch=c(rep(1,3),rep(2,3)),col=rainbow(6),lwd=2)
png(filename = "chorophyll.png")
plot(Date, Qs.data[,1],ylim=c(4,16),type="o",col=Qs.colours[1],lwd=2,cex=1.2,pch=ceiling(1/3),ylab="Chlorophyll (ug/ul)",cex.lab=1.3)
for(i in 2:6)
{
lines(Date,Qs.data[,i],type="o",col=Qs.colours[i],lwd=2,cex=1.2,pch=ceiling(i/3))
}
legend("topright",legend=paste("Q",1:6,sep=""),pch=c(rep(1,3),rep(2,3)),col=rainbow(6),lwd=2)
dev.off()
shiny::runApp('~/Dropbox/ChlamyNET')
runApp('~/Dropbox/ChlamyNET')
setwd("~/Dropbox/ATTRACTOR/network")
## Input parameters
## Transcription factor, file name containing targets and ZT value
input.xgmml.file <- "attractor.xgmml"
## Load the package required to read XML files.
library("XML")
library("methods")
## Parse the xgmml file making sure the attribute name spaces are kept
result <- xmlTreeParse(file = input.xgmml.file, addAttributeNamespaces = TRUE)
## Extract root node
rootNode <- xmlRoot(result)
## Extract nodes
node.elements <- xmlElementsByTagName(el = rootNode,name = "node")
## Store nodes info
number.nodes <- length(node.elements)
nodes.names <- vector(mode = "character",length = number.nodes)
nodes.x.pos <- vector(mode = "character",length = number.nodes)
nodes.y.pos <- vector(mode = "character",length = number.nodes)
i <- 1
for(i in 1:number.nodes)
{
current.node <- node.elements[[i]]
nodes.names[i] <- xmlAttrs(current.node)[["label"]]
node.graphic.attrs <- xmlAttrs(xmlElementsByTagName(el = current.node, name = "graphics")[[1]])
nodes.x.pos[i] <- node.graphic.attrs[["x"]]
nodes.y.pos[i] <- node.graphic.attrs[["y"]]
}
nodes.df <- data.frame(names=nodes.names,x.pos=nodes.x.pos,y.pos=nodes.y.pos)
head(nodes.df)
write.table(x = nodes.df, file = "attractor_network.tsv",quote = FALSE,sep = "\t",row.names = FALSE)
## Add info regarding clusters
peak.z0 <- read.table(file="clusters/peak_ZT0.txt")
## Add info regarding clusters
peak.zt0 <- read.table(file="clusters/peak_ZT0.txt")
head(peak.zt0)
## Add info regarding clusters
peak.zt0 <- read.table(file="clusters/peak_ZT0.txt",as.is=T)[[1]]
peak.zt0
peak.zt4 <- read.table(file="clusters/peak_ZT4.txt",as.is=T)[[1]]
peak.zt8 <- read.table(file="clusters/peak_ZT8.txt",as.is=T)[[1]]
peak.zt12 <- read.table(file="clusters/peak_ZT12.txt",as.is=T)[[1]]
## Add info regarding clusters
peak.zt0 <- read.table(file="clusters/peak_ZT0.txt",as.is=T)[[1]]
peak.zt4 <- read.table(file="clusters/peak_ZT4.txt",as.is=T)[[1]]
peak.zt8 <- read.table(file="clusters/peak_ZT8.txt",as.is=T)[[1]]
peak.zt12 <- read.table(file="clusters/peak_ZT12.txt",as.is=T)[[1]]
peak.zt16 <- read.table(file="clusters/peak_ZT16.txt",as.is=T)[[1]]
peak.zt20 <- read.table(file="clusters/peak_ZT20.txt",as.is=T)[[1]]
cluster.genes <- c(peak.zt0, peak.zt4,peak.zt8,peak.zt12,peak.zt16,peak.zt20)
names(cluster.genes) <- paste0("peak", c(rep(0,length(peak.zt0)),
rep(4,length(peak.zt4)),
rep(8,length(peak.zt8)),
rep(12,length(peak.zt12)),
rep(16,length(peak.zt16)),
rep(20,length(peak.zt20))))
nodes.df$names
as.vector(nodes.df$names)
cluster.genes <- as.vector(nodes.df$names)
cluster.genes <- c(peak.zt0, peak.zt4,peak.zt8,peak.zt12,peak.zt16,peak.zt20)
names(cluster.genes) <- paste0("peak", c(rep(0,length(peak.zt0)),
rep(4,length(peak.zt4)),
rep(8,length(peak.zt8)),
rep(12,length(peak.zt12)),
rep(16,length(peak.zt16)),
rep(20,length(peak.zt20))))
cluster.genes[as.vector(nodes.df$names)]
names(clusters.names) <- cluster.genes
clusters.names[as.vector(nodes.df$names)]
clusters.names <- paste0("peak", c(rep(0,length(peak.zt0)),
rep(4,length(peak.zt4)),
rep(8,length(peak.zt8)),
rep(12,length(peak.zt12)),
rep(16,length(peak.zt16)),
rep(20,length(peak.zt20))))
names(clusters.names) <- cluster.genes
clusters.names[as.vector(nodes.df$names)]
cluster.classification <- clusters.names[as.vector(nodes.df$names)]
names(cluster.classification) <- NULL
cluster.classification
nodes.df <- data.frame(nodes.df,cluster.classification)
colnames(nodes.df)
write.table(x = nodes.df, file = "attractor_network.tsv",quote = FALSE,sep = "\t",row.names = FALSE)
setwd("~/Dropbox/ATTRACTOR/network")
## Input parameters
## Transcription factor, file name containing targets and ZT value
input.xgmml.file <- "attractor.xgmml"
## Load the package required to read XML files.
library("XML")
library("methods")
## Parse the xgmml file making sure the attribute name spaces are kept
result <- xmlTreeParse(file = input.xgmml.file, addAttributeNamespaces = TRUE)
## Extract root node
rootNode <- xmlRoot(result)
## Extract nodes
node.elements <- xmlElementsByTagName(el = rootNode,name = "node")
## Store nodes info
number.nodes <- length(node.elements)
nodes.names <- vector(mode = "character",length = number.nodes)
nodes.x.pos <- vector(mode = "character",length = number.nodes)
nodes.y.pos <- vector(mode = "character",length = number.nodes)
for(i in 1:number.nodes)
{
current.node <- node.elements[[i]]
nodes.names[i] <- xmlAttrs(current.node)[["label"]]
node.graphic.attrs <- xmlAttrs(xmlElementsByTagName(el = current.node, name = "graphics")[[1]])
nodes.x.pos[i] <- node.graphic.attrs[["x"]]
nodes.y.pos[i] <- node.graphic.attrs[["y"]]
}
nodes.df <- data.frame(names=nodes.names,x.pos=nodes.x.pos,y.pos=nodes.y.pos)
head(nodes.df)
## Add info regarding clusters
peak.zt0 <- read.table(file="clusters/peak_ZT0.txt",as.is=T)[[1]]
peak.zt4 <- read.table(file="clusters/peak_ZT4.txt",as.is=T)[[1]]
peak.zt8 <- read.table(file="clusters/peak_ZT8.txt",as.is=T)[[1]]
peak.zt12 <- read.table(file="clusters/peak_ZT12.txt",as.is=T)[[1]]
peak.zt16 <- read.table(file="clusters/peak_ZT16.txt",as.is=T)[[1]]
peak.zt20 <- read.table(file="clusters/peak_ZT20.txt",as.is=T)[[1]]
cluster.genes <- c(peak.zt0, peak.zt4,peak.zt8,peak.zt12,peak.zt16,peak.zt20)
clusters.names <- paste0("peak", c(rep(0,length(peak.zt0)),
rep(4,length(peak.zt4)),
rep(8,length(peak.zt8)),
rep(12,length(peak.zt12)),
rep(16,length(peak.zt16)),
rep(20,length(peak.zt20))))
names(clusters.names) <- cluster.genes
cluster.classification <- clusters.names[as.vector(nodes.df$names)]
names(cluster.classification) <- NULL
nodes.df <- data.frame(nodes.df,cluster.classification)
write.table(x = nodes.df, file = "attractor_network.tsv",quote = FALSE,sep = "\t",row.names = FALSE)
setwd("~/Dropbox/ATTRACTOR/network/analysis")
## Load library and graph
library(igraph)
## Load ATTRACTOR network and extract gene names
atha.graph <- read.graph(file="../attractor.graphml", format = "graphml")
vertex.names <- V(atha.graph)$name
length(vertex.names)
## Initialise vectors to store topological parameters
atha.neighbors <- vector(mode="character",length=length(vertex.names))
atha.indegree <- vector(mode="numeric",length=length(vertex.names))
atha.outdegree <- vector(mode="numeric",length=length(vertex.names))
atha.trans <- vector(mode="numeric",length=length(vertex.names))
atha.close <- vector(mode="numeric",length=length(vertex.names))
atha.between <- vector(mode="numeric",length=length(vertex.names))
atha.eccent <- vector(mode="numeric",length=length(vertex.names))
## Loop to compute the different topological parameters and the names of the nodes
## connect to curren node (regulators)
for (i in 1:vcount(atha.graph))
{
if (length(neighbors(graph = atha.graph, v=vertex.names[i], mode="in")$name) == 0)
{
atha.neighbors[i] <- NA
} else
{
atha.neighbors[i] <- capture.output(cat(neighbors(graph = atha.graph, v=vertex.names[i], mode="in")$name, sep = ","))
}
atha.indegree[i] <- degree(graph = atha.graph, v=vertex.names[i],mode = "in")
atha.outdegree[i] <- degree(graph = atha.graph, v=vertex.names[i],mode = "out")
atha.trans[i] <- transitivity(graph = atha.graph, type = "local", vids=vertex.names[i])
atha.close[i] <- closeness(graph = atha.graph, vids=vertex.names[i], normalized = TRUE)
atha.between[i] <- betweenness(graph = atha.graph, v = vertex.names[i], normalized = TRUE)
atha.eccent[i] <- eccentricity(graph = atha.graph, v = vertex.names[i])
}
## Load library and graph
library(igraph)
## Load ATTRACTOR network and extract gene names
atha.graph <- read.graph(file="../attractor.graphml", format = "graphml")
vertex.names <- V(atha.graph)$name
length(vertex.names)
## Initialise vectors to store topological parameters
atha.neighbors <- vector(mode="character",length=length(vertex.names))
atha.indegree <- vector(mode="numeric",length=length(vertex.names))
atha.outdegree <- vector(mode="numeric",length=length(vertex.names))
atha.trans <- vector(mode="numeric",length=length(vertex.names))
atha.close <- vector(mode="numeric",length=length(vertex.names))
atha.between <- vector(mode="numeric",length=length(vertex.names))
atha.eccent <- vector(mode="numeric",length=length(vertex.names))
vcount(atha.graph)
## Loop to compute the different topological parameters and the names of the nodes
## connect to curren node (regulators)
for (i in 1:vcount(atha.graph))
{
print(i)
if (length(neighbors(graph = atha.graph, v=vertex.names[i], mode="in")$name) == 0)
{
atha.neighbors[i] <- NA
} else
{
atha.neighbors[i] <- capture.output(cat(neighbors(graph = atha.graph, v=vertex.names[i], mode="in")$name, sep = ","))
}
atha.indegree[i] <- degree(graph = atha.graph, v=vertex.names[i],mode = "in")
atha.outdegree[i] <- degree(graph = atha.graph, v=vertex.names[i],mode = "out")
atha.trans[i] <- transitivity(graph = atha.graph, type = "local", vids=vertex.names[i])
atha.close[i] <- closeness(graph = atha.graph, vids=vertex.names[i], normalized = TRUE)
atha.between[i] <- betweenness(graph = atha.graph, v = vertex.names[i], normalized = TRUE)
atha.eccent[i] <- eccentricity(graph = atha.graph, v = vertex.names[i])
}
## Generate data frame with the topological parameters
node.topological.parameters <- data.frame(vertex.names, atha.neighbors, atha.indegree,
atha.outdegree, atha.trans,
atha.close, atha.between, atha.eccent)
colnames(node.topological.parameters) <- c("names", "regulators", "indegree", "outdegree",
"transitivity", "closeness", "betweeness", "eccentricity")
rownames(node.topological.parameters) <- vertex.names
head(node.topological.parameters)
nrow(node.topological.parameters)
## Add topological parameters to file containing the info of the network used in the web app.
attractor.network <- read.table(file="../attractor_network.tsv",header=TRUE)
head(attractor.network)
nrow(attractor.network)
head(node.topological.parameters[attractor.network$names,])
attractor.network.topological.parameters <- cbind(attractor.network,
node.topological.parameters[as.vector(attractor.network$names),2:ncol(node.topological.parameters)])
head(attractor.network.topological.parameters)
write.table(attractor.network.topological.parameters, file="../attractor_network_topological_parameters.tsv", sep = "\t", quote = FALSE,
row.names = FALSE)
