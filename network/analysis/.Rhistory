factor.hora <- 180/(end.time - start.time)
max.time <- (start.time + end.time)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time && hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
} else
{
day.length <- (24 - start.time) + end.time
factor.hora <- 180/(day.length)
max.time <- start.time + (day.length)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time || hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
}
plot(time.points,var.cosw)
day.length <- (24 - start.time) + end.time
day.length
factor.hora <- 180/(day.length)
max.time <- start.time + (day.length)/2
max.time
start.time <- 9
end.time <- 1
if(end.time > start.time)
{
factor.hora <- 180/(end.time - start.time)
max.time <- (start.time + end.time)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time && hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
} else
{
day.length <- (24 - start.time) + end.time
factor.hora <- 180/(day.length)
max.time <- start.time + (day.length)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else if(hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - 24 + hora)/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
}
plot(time.points,var.cosw)
start.time <- 9
end.time <- 1
if(end.time > start.time)
{
factor.hora <- 180/(end.time - start.time)
max.time <- (start.time + end.time)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time && hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
} else
{
day.length <- (24 - start.time) + end.time
factor.hora <- 180/(day.length)
max.time <- start.time + (day.length)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else if(hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - 24 - hora)/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
}
plot(time.points,var.cosw)
start.time <- 9
end.time <- 1
if(end.time > start.time)
{
factor.hora <- 180/(end.time - start.time)
max.time <- (start.time + end.time)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time && hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
} else
{
day.length <- (24 - start.time) + end.time
factor.hora <- 180/(day.length)
max.time <- start.time + (day.length)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else if(hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - (hora+24))/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
}
plot(time.points,var.cosw)
start.time <- 10
end.time <- 2
if(end.time > start.time)
{
factor.hora <- 180/(end.time - start.time)
max.time <- (start.time + end.time)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time && hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
} else
{
day.length <- (24 - start.time) + end.time
factor.hora <- 180/(day.length)
max.time <- start.time + (day.length)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else if(hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - (hora+24))/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
}
plot(time.points,var.cosw)
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/Pedro_de_los_Reyes/arabidopsis_thaliana_clock_network/web_apps/network_visualizer')
runApp('Dropbox/Pedro_de_los_Reyes/arabidopsis_thaliana_clock_network/web_apps/peak_visualizer')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("ChIPseeker", version = "3.8")
BiocManager::install("ChIPseeker", version = "3.8")
BiocManager::install("ChIPseeker", version = "3.8")
library("ChIPSeeker")
BiocManager::install("ChIPseeker", version = "3.8")
library("ChIPSeeker")
library("ChIPseeker")
options(repos = BiocInstaller::biocinstallRepos())
getOption("repos")
rsconnect::appDependencies()
options(rsconnect.max.bundle.size=3145728000)
rsconnect::appDependencies()
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("BiocGenerics", version = "3.8")
options(repos = BiocInstaller::biocinstallRepos())
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("BiocInstaller", version = "3.8")
options(repos = BiocInstaller::biocinstallRepos())
getOption("repos")
library(ballgown)
## Instalación y carga de los paquetes necesarios. Sólo es necesario instalar los
## paquetes la primera vez que se ejecuta este script en un ordenador el resto de las
## veces bastará cargar los paquetes simplemente.
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("ballgown", version = "3.8")
BiocManager::install("genefilter", version = "3.8")
library(ballgown)
library(genefilter)
## Para cargar los datos es necesario crear previamente un fichero tabular
## que contenga como primera columna los nombres de las carpetas donde se guarda
## cada muesra típicamente sample1, sample2, etc ... El resto de columnas
## haran referencia al genotipo, tratamiento y demás caracteriśticas de cada muestra.
pheno.data <- read.csv("pheno_data.csv")
setwd("~/Dropbox/asignaturas/BMS/BMS2018/clases/rna_seq")
setwd("~/Dropbox/asignaturas/BMS/BMS2018/clases/rna_seq/samples")
setwd("~/Dropbox/asignaturas/BMS/BMS2018/clases/rna_seq/samples")
## Para cargar los datos es necesario crear previamente un fichero tabular
## que contenga como primera columna los nombres de las carpetas donde se guarda
## cada muesra típicamente sample1, sample2, etc ... El resto de columnas
## haran referencia al genotipo, tratamiento y demás caracteriśticas de cada muestra.
pheno.data <- read.csv("pheno_data.csv")
pheno.data
## La función ballgown se usa para cargar o leer los datos. Es necesario especificar
## el directorio donde se encuentra las muestras. En nuestro caso especificamos .
## para indicar que se encuentran en el actual directorio.
bg.data <- ballgown(dataDir = ".", samplePattern = "sample", pData=pheno.data)
bg.data
sampleNames(bg.data)
## La función gexpr extrae los niveles de expresión génicos en cada muestra
## medidos como FPKM (Fragments Per Kilobase of exon and Million of mapped reads)
gene.expression <- gexpr(bg.data)
head(gene.expression)
## Nombramos las columnas con los nombres de nuestras muestras.
colnames(gene.expression) <- c("col0_1","col0_2","abc_1","abc_2")
## Previsualizamos la similitud entre las réplicas
plot(log2(gene.expression[,1]+1),log2(gene.expression[,2]+1),pch=19,cex=0.7,xlab="col0_1",ylab=substitute(italic("col0_2")),cex.lab=1.25)
plot(log2(gene.expression[,3]+1),log2(gene.expression[,4]+1),pch=19,cex=0.7,xlab="abc_1",ylab=substitute(italic("abc_2")),cex.lab=1.25)
## Construimos un boxplot para comprobar que las distribuciones globales de las
## muestras son similares y comparables.
boxplot(log2(gene.expression + 1),col=rainbow(ncol(gene.expression)),ylab="log2(FPKM + 1)",cex.lab=1.5)
normalyzer.data <- data.frame(rownames(gene.expression),gene.expression)
dim(normalyzer.data)
head(.data)
head(normalyzer.data)
colnames(normalyzer.data) <- NULL
rownames(normalyzer.data) <- NULL
normalyzer.table <- rbind(c(0,rep(1:2,each=2)),
rbind(c("Gene",colnames(gene.expression)),normalyzer.data))
head(normalyzer.table)
i <- 1
gene.expression[,i]
quantile(gene.expression[,i],probs=0.75)
upper.quantiles <- vector(mode="numeric",length=ncol(gene.expression))
for(i in 1:ncol(gene.expression))
{
upper.quantiles[i] <- quantile(gene.expression[,i],probs=0.75)
}
upper.quantiles
for(i in 1:ncol(gene.expression))
{
gene.expression[,i] <- gene.expression[,i] / upper.quantiles[i]
}
log.gene.expression <- log2(gene.expression)
log.gene.expression <- log2(gene.expression+1)
boxplot(log.gene.expression,col=rainbow(ncol(gene.expression)),ylab="log2(FPKM + 1)",cex.lab=1.5)
boxplot(log.gene.expression,col=rainbow(ncol(gene.expression)),ylab="log2(FPKM + 1)",cex.lab=1.5,outline=F)
## Calculamos la matrix de expresión media.
col0 <- (log.gene.expression[,1] + log.gene.expression[,2])/2
## Calculamos la matrix de expresión media.
col0 <- (log.gene.expression[,"col0_1"] + log.gene.expression[,2])/2
## Calculamos la matrix de expresión media.
col0 <- (log.gene.expression[,"col0_1"] + log.gene.expression[,"col0_2"])/2
col0
abc <- (log.gene.expression[,"abc_1"] + log.gene.expression[,"abc_2"])/2
mean.expression <- matrix(c(col0,abc),ncol=2)
colnames(mean.expression) <- c("col0","abc")
rownames(mean.expression) <- names(col0)
head(mean.expression)
## Previsualizamos el efecto de la mutación en un scatterplot.
plot(col0,abc,pch=19,cex=0.7,xlab="Col0",ylab=substitute(italic("abc")),cex.lab=1.25)
library(limma)
experimental.design <- model.matrix(~ -1+factor(c(1,1,2,2)))
colnames(experimental.design) <- c("col0","abc")
linear.fit <- lmFit(log.gene.expression, experimental.design)
contrast.matrix <- makeContrasts(abc-col0,levels=c("abc","col0"))
contrast.linear.fit <- contrasts.fit(linear.fit, contrast.matrix)
contrast.linear.fit
experimental.design <- model.matrix(~ -1+factor(c(1,1,2,2)))
colnames(experimental.design) <- c("col0","abc")
linear.fit <- lmFit(log.gene.expression, experimental.design)
contrast.matrix <- makeContrasts(abc-col0,levels=c("col0","abc"))
contrast.linear.fit <- contrasts.fit(linear.fit, contrast.matrix)
contrast.results <- eBayes(contrast.linear.fit)
nrow(log.gene.expression)
col0.abc <- topTable(contrast.results, number=7507,coef=1,sort.by="logFC")
head(col0.abc)
fold.change.ablated.uninjured <- col0.abc$logFC
genes.ids.ablated.uninjured <- rownames(col0.abc)
fold.change <- col0.abc$logFC
genes.ids <- rownames(col0.abc)
activated.genes <- genes.ids[fold.change > 1]
repressed.genes <- genes.ids[fold.change < - 1]
length(activated.genes)
length(repressed.genes)
gen <- activated.genes[1]
original.data <- 2^final.data
expr.1 <- unlist(c(original.data[gen, 1:2]))
expr.2 <- unlist(c(original.data[gen, 3:4]))
mean.1 <- mean(expr.1)
mean.2 <- mean(expr.2)
sd.1 <- sd(expr.1)
sd.2 <- sd(expr.2)
means <- c(mean.1, mean.2)
sds <- c(sd.1, sd.2)
arrow.top <- means + sds
arrow.bottom <- means - sds
xpos <- barplot(means,ylim=c(0,1.5*max(arrow.top)),col=rainbow(2))
original.data <- 2^log.gene.expression
expr.1 <- unlist(c(original.data[gen, 1:2]))
expr.2 <- unlist(c(original.data[gen, 3:4]))
mean.1 <- mean(expr.1)
mean.2 <- mean(expr.2)
sd.1 <- sd(expr.1)
sd.2 <- sd(expr.2)
means <- c(mean.1, mean.2)
sds <- c(sd.1, sd.2)
arrow.top <- means + sds
arrow.bottom <- means - sds
xpos <- barplot(means,ylim=c(0,1.5*max(arrow.top)),col=rainbow(2))
arrows(xpos, arrow.top, xpos, arrow.bottom,code = 3,angle=90,length=0.2)
## Load library and graph
library(igraph)
setwd("~/Dropbox/ATTRACTOR/network/analysis")
atha.graph <- read.graph(file="../attractor.graphml", format = "graphml")
atha.graph <- read.graph(file="../attractor.graphml", format = "gml")
atha.graph <- read.graph(file="../attractor.graphml", format = "graphml")
atha.graph <- read.graph(file="../attractor.graphml", format = "graphml")
atha.graph <- read.graph(file="../attractor.graphml", format = "graphml")
atha.graph <- read.graph(file="../attractor_2.graphml", format = "graphml")
vertex.names <- V(atha.graph)$name
vertex.names
##Load ATTRACTOR network and extract gene names
atha.graph <- read.graph(file="../attractor_2.graphml", format = "graphml")
vertex.names <- V(atha.graph)$name
##Load ATTRACTOR network and extract gene names
atha.graph <- read.graph(file="../attractor.graphml", format = "graphml")
vertex.names <- V(atha.graph)$name
atha.neighbors <- vector(mode="character",length=length(vertex.names))
