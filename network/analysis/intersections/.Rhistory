{
j <- j + 1
intersection[j,1] <- current.chr
intersection[j,2] <- hit.2[1,2]
intersection[j,3] <- current.end
}
}
}
return(list(intersection=intersection[1:j,],size=j))
}
#Function to randomize peaks
randomize.peaks <- function(input.peaks,chr.lengths)
{
random.numbers <- runif(n = nrow(input.peaks))
random.starts <- ceiling(random.numbers * chr.lengths[input.peaks$V1])
random.ends <- random.starts + (input.peaks$V3 - input.peaks$V2)
random.peaks <- matrix(c(input.peaks$V1,random.starts,random.ends),ncol=3)
return(random.peaks)
}
##Loop to check the intersection of binding regions (bed files) between all the transcription factors together and store the results in a table####
chromosomes.length <- read.table(file="../../../web_apps/peak_visualizer/data/bed_files/atha_chr_lengths.txt",as.is=T)[[1]]
number.randomisation <- 10
bed.files <- list.files(path = "../../../web_apps/peak_visualizer/data/bed_files/", pattern = "peaks.narrowPeak")
combinations <- expand.grid(bed.files, bed.files)
bed.intersections <- matrix(ncol = 6, nrow = nrow(combinations))
colnames(bed.intersections) <- c("TF1", "TF2", "p-value", "fdr", "number of intersections", "Genes" )
txdb <- TxDb.Athaliana.BioMart.plantsmart28
library(TxDb.Athaliana.BioMart.plantsmart28)
library(org.At.tair.db)
library(ChIPseeker)
number.randomisation <- 10
i <- 265
# print(paste0("test number ", i, " of ", nrow(combinations)))
print(paste0((i/total.tests)*100, " %"))
peaks1 <- read.table(file = paste0("../../../web_apps/peak_visualizer/data/bed_files/", combinations[i,1]))
peaks2 <- read.table(file = paste0("../../../web_apps/peak_visualizer/data/bed_files/", combinations[i,2]))
real.intersection <- intersectBed(peaks.set1 = peaks1, peaks.set2 = peaks2)
real.intersection
real.intersection[[2]]
real.intersection[[2]] > 0
random.intersections <- vector(mode = "numeric",length=number.randomisation) #Creating vector
for(j in 1:number.randomisation)
{
print(j)
# random.peaks2 <- matrix(nrow=nrow(peaks2),ncol=3) #Matriz con 3 columnas, una para el cromosoma, otra para el comienzo y otra para el final de la región aleatoria.
# for(k in 1:nrow(peaks2))
# {
#   current.chr <- peaks2[k,1][[1]] #Chr de la iésima marca real
#   current.start <- peaks2[k,2] #Start de la iésima marca real
#   current.end <- peaks2[k,3] #End de la iésima marca real
#   current.length <- current.end - current.start #Longitud de la iésima marca real
#
#   chr.length <- chromosomes.length[current.chr] #Length del actual cromosoma
#   #Ahora genero los mismos datos para regiones aleatorias
#   random.start <- floor(runif(n = 1,min = 1,max = chr.length))
#   random.end <- random.start + current.length
#
#   random.peaks2[k,1] <- current.chr
#   random.peaks2[k,2] <- random.start
#   random.peaks2[k,3] <- random.end
# }
random.peaks2 <- randomize.peaks(input.peaks = peaks2, chr.lengths = chromosomes.length)
random.intersections[j] <- intersectBed(peaks.set1 = peaks1, peaks.set2 = random.peaks2 )[[2]]
}
p.value <- sum(random.intersections > real.intersection[[2]]) / number.randomisation
p.value == 0
random.intersections
p.value <- sum(random.intersections > real.intersection[[2]]) / number.randomisation
p.value
colnames(real.intersection[[1]]) <- c("chromosome", "start", "end")
granges.intersection <- makeGRangesFromDataFrame(real.intersection[[1]],
keep.extra.columns=FALSE,
ignore.strand=FALSE,
seqinfo=NULL,
seqnames.field="chromosome",
start.field="start",
end.field="end",
starts.in.df.are.0based=FALSE)
real.intersection[[1]]
as.matrix(real.intersection[[1]])
as.data.frame(real.intersection[[1]])
colnames(real.intersection[[1]]) <- c("chromosome", "start", "end")
real.intersection[[1]]
colnames(real.intersection[[1]], drop=F) <- c("chromosome", "start", "end")
real.intersection[[1]][1,drop=F]
real.intersection[[1]]
combinations[265,]
#####Intersections between binding regions in DNA (BED files)####
#Reading the bed files of the transcription factors
peaks1 <- read.table(file = "../../../web_apps/peak_visualizer/data/bed_files/ELF3_ZT0_1_peaks.narrowPeak)
#####Intersections between binding regions in DNA (BED files)####
#Reading the bed files of the transcription factors
peaks1 <- read.table(file = "../../../web_apps/peak_visualizer/data/bed_files/ELF3_ZT0_1_peaks.narrowPeak")
#####Intersections between binding regions in DNA (BED files)####
#Reading the bed files of the transcription factors
peaks1 <- read.table(file = "../../../web_apps/peak_visualizer/data/bed_files/ELF3_ZT0_1_peaks.narrowPeak")
head(peaks1)
peaks2 <- read.table(file = "../../../web_apps/peak_visualizer/data/bed_files/PIF3_peaks.narrowPeak")
head(peaks2)
intersectBed <- function(peaks.set1, peaks.set2)
{
intersection <- matrix(ncol = 3, nrow=min(nrow(peaks.set1),nrow(peaks.set2)) )
j <- 0
for (i in 1:nrow(peaks.set1))
{
#Set the current peak values of set1
current.chr <- as.numeric(peaks.set1[i,1])
current.start <- peaks.set1[i,2]
current.end <- peaks.set1[i,3]
#Checking if there is intersection between the current peak and any peak of set2
hit.1 <- subset(peaks.set2, peaks.set2[,1]==current.chr & peaks.set2[,2]<=current.start & peaks.set2[,3]>=current.start)
option1 <- nrow(hit.1)
if(option1>0)
{
j <- j + 1
intersection[j,1] <- current.chr
intersection[j,2] <- current.start
intersection[j,3] <- hit.1[1,3]
} else
{
hit.2 <- subset(peaks.set2, peaks.set2[,1]==current.chr & peaks.set2[,2]<=current.end & peaks.set2[,3]>=current.end)
option2 <- nrow(hit.2)
if(option2 > 0)
{
j <- j + 1
intersection[j,1] <- current.chr
intersection[j,2] <- hit.2[1,2]
intersection[j,3] <- current.end
}
}
}
return(list(intersection=intersection[1:j,],size=j))
}
peaks.set1 <- peaks1
peaks.set2 <- peaks2
intersection <- matrix(ncol = 3, nrow=min(nrow(peaks.set1),nrow(peaks.set2)) )
intersection
#Set the current peak values of set1
current.chr <- as.numeric(peaks.set1[i,1])
current.start <- peaks.set1[i,2]
current.end <- peaks.set1[i,3]
current.chr
current.start
current.end
colnames(real.intersection[[1]]) <- c("chromosome", "start", "end")
as.data.frame(real.intersection[[1]])
as.data.frame(real.intersection[[1]], ncol=3)
as.data.frame(real.intersection[[1]], ncol=3, nrow=1)
as.matrix(real.intersection[[1]], ncol=3)
as.matrix(real.intersection[[1]], by.row=TRUE)
as.matrix(real.intersection[[1]], by.col=TRUE)
matrix(real.intersection[[1]], ncol = 3)
real.intersection[[2]]==1
real.intersection[[1]] <- matrix(real.intersection[[1]], ncol = 3)
colnames(real.intersection[[1]]) <- c("chromosome", "start", "end")
real.intersection[[1]]
colnames(real.intersection[[1]]) <- c("chromosome", "start", "end")
granges.intersection <- makeGRangesFromDataFrame(real.intersection[[1]],
keep.extra.columns=FALSE,
ignore.strand=FALSE,
seqinfo=NULL,
seqnames.field="chromosome",
start.field="start",
end.field="end",
starts.in.df.are.0based=FALSE)
peakAnno <- annotatePeak(granges.intersection, tssRegion=c(-2000, 0),
TxDb=txdb, annoDb="org.At.tair.db")
txdb <- TxDb.Athaliana.BioMart.plantsmart28
peakAnno <- annotatePeak(granges.intersection, tssRegion=c(-2000, 0),
TxDb=txdb, annoDb="org.At.tair.db")
annot.peaks <- as.data.frame(peakAnno)
annot.peaks
# target.genes <- subset(annot.peaks, distanceToTSS >= 2000 | distanceToTSS <= -2000)$geneId
target.genes <- subset(annot.peaks, annotation != "Downstream (<1kb)" & annotation != "Downstream (1-2kb)"
& annotation != "Distal Intergenic" & annotation != "Downstream (2-3kb)")$geneId
target.genes <- paste(target.genes, collapse = ",")
target.genes
print(paste0("test number ", i))
setwd("~/Dropbox/github_repos/ATTRACTOR/network/analysis/intersections")
intersectBed <- function(peaks.set1, peaks.set2)
{
intersection <- matrix(ncol = 3, nrow=min(nrow(peaks.set1),nrow(peaks.set2)) )
j <- 0
for (i in 1:nrow(peaks.set1))
{
#Set the current peak values of set1
current.chr <- as.numeric(peaks.set1[i,1])
current.start <- peaks.set1[i,2]
current.end <- peaks.set1[i,3]
#Checking if there is intersection between the current peak and any peak of set2
hit.1 <- subset(peaks.set2, peaks.set2[,1]==current.chr & peaks.set2[,2]<=current.start & peaks.set2[,3]>=current.start)
option1 <- nrow(hit.1)
if(option1>0)
{
j <- j + 1
intersection[j,1] <- current.chr
intersection[j,2] <- current.start
intersection[j,3] <- hit.1[1,3]
} else
{
hit.2 <- subset(peaks.set2, peaks.set2[,1]==current.chr & peaks.set2[,2]<=current.end & peaks.set2[,3]>=current.end)
option2 <- nrow(hit.2)
if(option2 > 0)
{
j <- j + 1
intersection[j,1] <- current.chr
intersection[j,2] <- hit.2[1,2]
intersection[j,3] <- current.end
}
}
}
return(list(intersection=intersection[1:j,],size=j))
}
#Function to randomize peaks
randomize.peaks <- function(input.peaks,chr.lengths)
{
random.numbers <- runif(n = nrow(input.peaks))
random.starts <- ceiling(random.numbers * chr.lengths[input.peaks$V1])
random.ends <- random.starts + (input.peaks$V3 - input.peaks$V2)
random.peaks <- matrix(c(input.peaks$V1,random.starts,random.ends),ncol=3)
return(random.peaks)
}
##Loop to check the intersection of binding regions (bed files) between all the transcription factors together and store the results in a table####
chromosomes.length <- read.table(file="../../../web_apps/peak_visualizer/data/bed_files/atha_chr_lengths.txt",as.is=T)[[1]]
number.randomisation <- 1000
bed.files <- list.files(path = "../../../web_apps/peak_visualizer/data/bed_files/", pattern = "peaks.narrowPeak")
combinations <- expand.grid(bed.files, bed.files)
bed.intersections <- matrix(ncol = 6, nrow = nrow(combinations))
colnames(bed.intersections) <- c("TF1", "TF2", "p-value", "fdr", "number of intersections", "Genes" )
#####Intersections between binding regions in DNA (BED files)####
##Load libraries
library(TxDb.Athaliana.BioMart.plantsmart28)
library(org.At.tair.db)
library(ChIPseeker)
i <- 51
# print(paste0("test number ", i, " of ", nrow(combinations)))
print(paste0((i/total.tests)*100, " %"))
peaks1 <- read.table(file = paste0("../../../web_apps/peak_visualizer/data/bed_files/", combinations[i,1]))
peaks2 <- read.table(file = paste0("../../../web_apps/peak_visualizer/data/bed_files/", combinations[i,2]))
real.intersection <- intersectBed(peaks.set1 = peaks1, peaks.set2 = peaks2)
if (real.intersection[[2]] > 0)
{
random.intersections <- vector(mode = "numeric",length=number.randomisation) #Creating vector
for(j in 1:number.randomisation)
{
print(j)
# random.peaks2 <- matrix(nrow=nrow(peaks2),ncol=3) #Matriz con 3 columnas, una para el cromosoma, otra para el comienzo y otra para el final de la región aleatoria.
# for(k in 1:nrow(peaks2))
# {
#   current.chr <- peaks2[k,1][[1]] #Chr de la iésima marca real
#   current.start <- peaks2[k,2] #Start de la iésima marca real
#   current.end <- peaks2[k,3] #End de la iésima marca real
#   current.length <- current.end - current.start #Longitud de la iésima marca real
#
#   chr.length <- chromosomes.length[current.chr] #Length del actual cromosoma
#   #Ahora genero los mismos datos para regiones aleatorias
#   random.start <- floor(runif(n = 1,min = 1,max = chr.length))
#   random.end <- random.start + current.length
#
#   random.peaks2[k,1] <- current.chr
#   random.peaks2[k,2] <- random.start
#   random.peaks2[k,3] <- random.end
# }
random.peaks2 <- randomize.peaks(input.peaks = peaks2, chr.lengths = chromosomes.length)
random.intersections[j] <- intersectBed(peaks.set1 = peaks1, peaks.set2 = random.peaks2 )[[2]]
}
p.value <- sum(random.intersections > real.intersection[[2]]) / number.randomisation
if( p.value == 0)
{
p.value <- 1/number.randomisation
}
if (real.intersection[[2]]==1)
{
real.intersection[[1]] <- matrix(real.intersection[[1]], ncol = 3)
}
colnames(real.intersection[[1]]) <- c("chromosome", "start", "end")
granges.intersection <- makeGRangesFromDataFrame(real.intersection[[1]],
keep.extra.columns=FALSE,
ignore.strand=FALSE,
seqinfo=NULL,
seqnames.field="chromosome",
start.field="start",
end.field="end",
starts.in.df.are.0based=FALSE)
peakAnno <- annotatePeak(granges.intersection, tssRegion=c(-2000, 0),
TxDb=txdb, annoDb="org.At.tair.db")
annot.peaks <- as.data.frame(peakAnno)
# target.genes <- subset(annot.peaks, distanceToTSS >= 2000 | distanceToTSS <= -2000)$geneId
target.genes <- subset(annot.peaks, annotation != "Downstream (<1kb)" & annotation != "Downstream (1-2kb)"
& annotation != "Distal Intergenic" & annotation != "Downstream (2-3kb)")$geneId
target.genes <- paste(target.genes, collapse = ",")
bed.intersections[i,1] <- strsplit(x = as.character(combinations[i,1]), split = "_peaks")[[1]][1]
bed.intersections[i,2] <- strsplit(x = as.character(combinations[i,2]), split = "_peaks")[[1]][1]
bed.intersections[i,3] <- p.value
bed.intersections[i,5] <- nrow(real.intersection)
bed.intersections[i,6] <- target.genes
} else
{
bed.intersections[i,1] <- strsplit(x = as.character(combinations[i,1]), split = "_peaks")[[1]][1]
bed.intersections[i,2] <- strsplit(x = as.character(combinations[i,2]), split = "_peaks")[[1]][1]
bed.intersections[i,3] <- NA
bed.intersections[i,5] <- "No intersection"
bed.intersections[i,6] <- NA
}
number.randomisation <- 10
peaks1 <- read.table(file = paste0("../../../web_apps/peak_visualizer/data/bed_files/", combinations[i,1]))
peaks2 <- read.table(file = paste0("../../../web_apps/peak_visualizer/data/bed_files/", combinations[i,2]))
real.intersection <- intersectBed(peaks.set1 = peaks1, peaks.set2 = peaks2)
if (real.intersection[[2]] > 0)
{
random.intersections <- vector(mode = "numeric",length=number.randomisation) #Creating vector
for(j in 1:number.randomisation)
{
print(j)
# random.peaks2 <- matrix(nrow=nrow(peaks2),ncol=3) #Matriz con 3 columnas, una para el cromosoma, otra para el comienzo y otra para el final de la región aleatoria.
# for(k in 1:nrow(peaks2))
# {
#   current.chr <- peaks2[k,1][[1]] #Chr de la iésima marca real
#   current.start <- peaks2[k,2] #Start de la iésima marca real
#   current.end <- peaks2[k,3] #End de la iésima marca real
#   current.length <- current.end - current.start #Longitud de la iésima marca real
#
#   chr.length <- chromosomes.length[current.chr] #Length del actual cromosoma
#   #Ahora genero los mismos datos para regiones aleatorias
#   random.start <- floor(runif(n = 1,min = 1,max = chr.length))
#   random.end <- random.start + current.length
#
#   random.peaks2[k,1] <- current.chr
#   random.peaks2[k,2] <- random.start
#   random.peaks2[k,3] <- random.end
# }
random.peaks2 <- randomize.peaks(input.peaks = peaks2, chr.lengths = chromosomes.length)
random.intersections[j] <- intersectBed(peaks.set1 = peaks1, peaks.set2 = random.peaks2 )[[2]]
}
p.value <- sum(random.intersections > real.intersection[[2]]) / number.randomisation
if( p.value == 0)
{
p.value <- 1/number.randomisation
}
if (real.intersection[[2]]==1)
{
real.intersection[[1]] <- matrix(real.intersection[[1]], ncol = 3)
}
colnames(real.intersection[[1]]) <- c("chromosome", "start", "end")
granges.intersection <- makeGRangesFromDataFrame(real.intersection[[1]],
keep.extra.columns=FALSE,
ignore.strand=FALSE,
seqinfo=NULL,
seqnames.field="chromosome",
start.field="start",
end.field="end",
starts.in.df.are.0based=FALSE)
peakAnno <- annotatePeak(granges.intersection, tssRegion=c(-2000, 0),
TxDb=txdb, annoDb="org.At.tair.db")
annot.peaks <- as.data.frame(peakAnno)
# target.genes <- subset(annot.peaks, distanceToTSS >= 2000 | distanceToTSS <= -2000)$geneId
target.genes <- subset(annot.peaks, annotation != "Downstream (<1kb)" & annotation != "Downstream (1-2kb)"
& annotation != "Distal Intergenic" & annotation != "Downstream (2-3kb)")$geneId
target.genes <- paste(target.genes, collapse = ",")
bed.intersections[i,1] <- strsplit(x = as.character(combinations[i,1]), split = "_peaks")[[1]][1]
bed.intersections[i,2] <- strsplit(x = as.character(combinations[i,2]), split = "_peaks")[[1]][1]
bed.intersections[i,3] <- p.value
bed.intersections[i,5] <- nrow(real.intersection)
bed.intersections[i,6] <- target.genes
} else
{
bed.intersections[i,1] <- strsplit(x = as.character(combinations[i,1]), split = "_peaks")[[1]][1]
bed.intersections[i,2] <- strsplit(x = as.character(combinations[i,2]), split = "_peaks")[[1]][1]
bed.intersections[i,3] <- NA
bed.intersections[i,5] <- "No intersection"
bed.intersections[i,6] <- NA
}
txdb <- TxDb.Athaliana.BioMart.plantsmart28
peaks1 <- read.table(file = paste0("../../../web_apps/peak_visualizer/data/bed_files/", combinations[i,1]))
peaks2 <- read.table(file = paste0("../../../web_apps/peak_visualizer/data/bed_files/", combinations[i,2]))
real.intersection <- intersectBed(peaks.set1 = peaks1, peaks.set2 = peaks2)
if (real.intersection[[2]] > 0)
{
random.intersections <- vector(mode = "numeric",length=number.randomisation) #Creating vector
for(j in 1:number.randomisation)
{
print(j)
# random.peaks2 <- matrix(nrow=nrow(peaks2),ncol=3) #Matriz con 3 columnas, una para el cromosoma, otra para el comienzo y otra para el final de la región aleatoria.
# for(k in 1:nrow(peaks2))
# {
#   current.chr <- peaks2[k,1][[1]] #Chr de la iésima marca real
#   current.start <- peaks2[k,2] #Start de la iésima marca real
#   current.end <- peaks2[k,3] #End de la iésima marca real
#   current.length <- current.end - current.start #Longitud de la iésima marca real
#
#   chr.length <- chromosomes.length[current.chr] #Length del actual cromosoma
#   #Ahora genero los mismos datos para regiones aleatorias
#   random.start <- floor(runif(n = 1,min = 1,max = chr.length))
#   random.end <- random.start + current.length
#
#   random.peaks2[k,1] <- current.chr
#   random.peaks2[k,2] <- random.start
#   random.peaks2[k,3] <- random.end
# }
random.peaks2 <- randomize.peaks(input.peaks = peaks2, chr.lengths = chromosomes.length)
random.intersections[j] <- intersectBed(peaks.set1 = peaks1, peaks.set2 = random.peaks2 )[[2]]
}
p.value <- sum(random.intersections > real.intersection[[2]]) / number.randomisation
if( p.value == 0)
{
p.value <- 1/number.randomisation
}
if (real.intersection[[2]]==1)
{
real.intersection[[1]] <- matrix(real.intersection[[1]], ncol = 3)
}
colnames(real.intersection[[1]]) <- c("chromosome", "start", "end")
granges.intersection <- makeGRangesFromDataFrame(real.intersection[[1]],
keep.extra.columns=FALSE,
ignore.strand=FALSE,
seqinfo=NULL,
seqnames.field="chromosome",
start.field="start",
end.field="end",
starts.in.df.are.0based=FALSE)
peakAnno <- annotatePeak(granges.intersection, tssRegion=c(-2000, 0),
TxDb=txdb, annoDb="org.At.tair.db")
annot.peaks <- as.data.frame(peakAnno)
# target.genes <- subset(annot.peaks, distanceToTSS >= 2000 | distanceToTSS <= -2000)$geneId
target.genes <- subset(annot.peaks, annotation != "Downstream (<1kb)" & annotation != "Downstream (1-2kb)"
& annotation != "Distal Intergenic" & annotation != "Downstream (2-3kb)")$geneId
target.genes <- paste(target.genes, collapse = ",")
bed.intersections[i,1] <- strsplit(x = as.character(combinations[i,1]), split = "_peaks")[[1]][1]
bed.intersections[i,2] <- strsplit(x = as.character(combinations[i,2]), split = "_peaks")[[1]][1]
bed.intersections[i,3] <- p.value
bed.intersections[i,5] <- nrow(real.intersection)
bed.intersections[i,6] <- target.genes
} else
{
bed.intersections[i,1] <- strsplit(x = as.character(combinations[i,1]), split = "_peaks")[[1]][1]
bed.intersections[i,2] <- strsplit(x = as.character(combinations[i,2]), split = "_peaks")[[1]][1]
bed.intersections[i,3] <- NA
bed.intersections[i,5] <- "No intersection"
bed.intersections[i,6] <- NA
}
nrow(real.intersection)
real.intersection[[2]]
nrow(real.intersection[[1]])
if (real.intersection[[2]] > 0)
{
random.intersections <- vector(mode = "numeric",length=number.randomisation) #Creating vector
for(j in 1:number.randomisation)
{
print(j)
# random.peaks2 <- matrix(nrow=nrow(peaks2),ncol=3) #Matriz con 3 columnas, una para el cromosoma, otra para el comienzo y otra para el final de la región aleatoria.
# for(k in 1:nrow(peaks2))
# {
#   current.chr <- peaks2[k,1][[1]] #Chr de la iésima marca real
#   current.start <- peaks2[k,2] #Start de la iésima marca real
#   current.end <- peaks2[k,3] #End de la iésima marca real
#   current.length <- current.end - current.start #Longitud de la iésima marca real
#
#   chr.length <- chromosomes.length[current.chr] #Length del actual cromosoma
#   #Ahora genero los mismos datos para regiones aleatorias
#   random.start <- floor(runif(n = 1,min = 1,max = chr.length))
#   random.end <- random.start + current.length
#
#   random.peaks2[k,1] <- current.chr
#   random.peaks2[k,2] <- random.start
#   random.peaks2[k,3] <- random.end
# }
random.peaks2 <- randomize.peaks(input.peaks = peaks2, chr.lengths = chromosomes.length)
random.intersections[j] <- intersectBed(peaks.set1 = peaks1, peaks.set2 = random.peaks2 )[[2]]
}
p.value <- sum(random.intersections > real.intersection[[2]]) / number.randomisation
if( p.value == 0)
{
p.value <- 1/number.randomisation
}
if (real.intersection[[2]]==1)
{
real.intersection[[1]] <- matrix(real.intersection[[1]], ncol = 3)
}
colnames(real.intersection[[1]]) <- c("chromosome", "start", "end")
granges.intersection <- makeGRangesFromDataFrame(real.intersection[[1]],
keep.extra.columns=FALSE,
ignore.strand=FALSE,
seqinfo=NULL,
seqnames.field="chromosome",
start.field="start",
end.field="end",
starts.in.df.are.0based=FALSE)
peakAnno <- annotatePeak(granges.intersection, tssRegion=c(-2000, 0),
TxDb=txdb, annoDb="org.At.tair.db")
annot.peaks <- as.data.frame(peakAnno)
# target.genes <- subset(annot.peaks, distanceToTSS >= 2000 | distanceToTSS <= -2000)$geneId
target.genes <- subset(annot.peaks, annotation != "Downstream (<1kb)" & annotation != "Downstream (1-2kb)"
& annotation != "Distal Intergenic" & annotation != "Downstream (2-3kb)")$geneId
target.genes <- paste(target.genes, collapse = ",")
bed.intersections[i,1] <- strsplit(x = as.character(combinations[i,1]), split = "_peaks")[[1]][1]
bed.intersections[i,2] <- strsplit(x = as.character(combinations[i,2]), split = "_peaks")[[1]][1]
bed.intersections[i,3] <- p.value
bed.intersections[i,5] <- nrow(real.intersection[[1]])
bed.intersections[i,6] <- target.genes
} else
{
bed.intersections[i,1] <- strsplit(x = as.character(combinations[i,1]), split = "_peaks")[[1]][1]
bed.intersections[i,2] <- strsplit(x = as.character(combinations[i,2]), split = "_peaks")[[1]][1]
bed.intersections[i,3] <- NA
bed.intersections[i,5] <- "No intersection"
bed.intersections[i,6] <- NA
}
bed.intersections[i,1]
bed.intersections[i,2]
bed.intersections[i,3]
bed.intersections[i,5]
bed.intersections[i,6]
