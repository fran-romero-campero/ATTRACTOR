real.intersection <- intersectBed(peaks.set1 = peaks1, peaks.set2 = peaks2)
random.intersections <- vector(mode = "numeric",length=number.randomisation) #Creating vector
for(j in 1:number.randomisation)
{
print(paste0("randomisation number ",j, " of combination number ", i))
random.peaks2 <- matrix(nrow=nrow(peaks2),ncol=3) #Matriz con 3 columnas, una para el cromosoma, otra para el comienzo y otra para el final de la región aleatoria.
for(k in 1:nrow(peaks2))
{
current.chr <- peaks2[k,1][[1]] #Chr de la iésima marca real
current.start <- peaks2[k,2] #Start de la iésima marca real
current.end <- peaks2[k,3] #End de la iésima marca real
current.length <- current.end - current.start #Longitud de la iésima marca real
chr.length <- chromosomes.length[current.chr] #Length del actual cromosoma
#Ahora genero los mismos datos para regiones aleatorias
random.start <- floor(runif(n = 1,min = 1,max = chr.length))
random.end <- random.start + current.length
random.peaks2[k,1] <- current.chr
random.peaks2[k,2] <- random.start
random.peaks2[k,3] <- random.end
}
random.intersections[j] <- nrow(intersectBed(peaks.set1 = peaks1, peaks.set2 = random.peaks2 ))
}
p.value <- sum(random.intersections > nrow(real.intersection)) / number.randomisation
bed.intersections[i,1] <- strsplit(x = as.character(combinations[i,1]), split = "_peaks")[[1]][1]
bed.intersections[i,2] <- strsplit(x = as.character(combinations[i,2]), split = "_peaks")[[1]][1]
bed.intersections[i,3] <- p.value
}
random.intersections
print(paste0("aprox ", (j + (i-1)*20))/number.randomisation*nrow(combinations)))," %")
nrow(combinations)
number.randomisation*nrow(combinations)
print(paste0("aprox ", (j+(i-1)*20)/(number.randomisation*nrow(combinations)))," %")
j+(i-1)*20)/(number.randomisation*nrow(combinations))
number.randomisation*nrow(combinations)
j+(i-1)*20)/number.randomisation*nrow(combinations)
j
i
j+(i-1)*20
number.randomisation*nrow(combinations)
(j+(i-1)*20)/number.randomisation*nrow(combinations))
print(paste0("aprox ", j+(i-1)*20)/number.randomisation*nrow(combinations)," %")
j+(i-1)*20)/number.randomisation*nrow(combinations)
j+(i-1)*20/number.randomisation*nrow(combinations)
print(paste0("aprox ", j+(i-1)*20/number.randomisation*nrow(combinations)," %")
random.peaks2 <- matrix(nrow=nrow(peaks2),ncol=3) #Matriz con 3 columnas, una para el cromosoma, otra para el comienzo y otra para el final de la región aleatoria.
for(k in 1:nrow(peaks2))
{
current.chr <- peaks2[k,1][[1]] #Chr de la iésima marca real
current.start <- peaks2[k,2] #Start de la iésima marca real
current.end <- peaks2[k,3] #End de la iésima marca real
current.length <- current.end - current.start #Longitud de la iésima marca real
chr.length <- chromosomes.length[current.chr] #Length del actual cromosoma
#Ahora genero los mismos datos para regiones aleatorias
random.start <- floor(runif(n = 1,min = 1,max = chr.length))
random.end <- random.start + current.length
random.peaks2[k,1] <- current.chr
random.peaks2[k,2] <- random.start
random.peaks2[k,3] <- random.end
}
random.intersections[j] <- nrow(intersectBed(peaks.set1 = peaks1, peaks.set2 = random.peaks2 ))
print(paste0("aprox ", ((i-1)+j)/total.randomisation, " %"))
total.randomisation <- number.randomisation*nrow(combinations) #just to see the progress
print(paste0("aprox ", ((i-1)+j)/total.randomisation, " %"))
##Loop to check the intersection of binding regions (bed files) between all the transcription factors together and store the results in a table####
number.randomisation <- 5
bed.files <- list.files(path = "../../../web_apps/peak_visualizer/data/bed_files/", pattern = "peaks.narrowPeak")
combinations <- expand.grid(bed.files, bed.files)
bed.intersections <- matrix(ncol = 5, nrow = nrow(combinations))
colnames(bed.intersections) <- c("TF1", "TF2", "p-value", "fdr", "Genes")
total.randomisation <- number.randomisation*nrow(combinations) #just to see the progress
i <- 5
for (i in 1:nrow(combinations))
{
peaks2 <- read.table(file = paste0("../../../web_apps/peak_visualizer/data/bed_files/", combinations[i,2]))
peaks1 <- read.table(file = paste0("../../../web_apps/peak_visualizer/data/bed_files/", combinations[i,1]))
real.intersection <- intersectBed(peaks.set1 = peaks1, peaks.set2 = peaks2)
random.intersections <- vector(mode = "numeric",length=number.randomisation) #Creating vector
for(j in 1:number.randomisation)
{
print(paste0(((i-1)+j)/total.randomisation, " %"))
random.peaks2 <- matrix(nrow=nrow(peaks2),ncol=3) #Matriz con 3 columnas, una para el cromosoma, otra para el comienzo y otra para el final de la región aleatoria.
for(k in 1:nrow(peaks2))
{
current.chr <- peaks2[k,1][[1]] #Chr de la iésima marca real
current.start <- peaks2[k,2] #Start de la iésima marca real
current.end <- peaks2[k,3] #End de la iésima marca real
current.length <- current.end - current.start #Longitud de la iésima marca real
chr.length <- chromosomes.length[current.chr] #Length del actual cromosoma
#Ahora genero los mismos datos para regiones aleatorias
random.start <- floor(runif(n = 1,min = 1,max = chr.length))
random.end <- random.start + current.length
random.peaks2[k,1] <- current.chr
random.peaks2[k,2] <- random.start
random.peaks2[k,3] <- random.end
}
random.intersections[j] <- nrow(intersectBed(peaks.set1 = peaks1, peaks.set2 = random.peaks2 ))
}
p.value <- sum(random.intersections > nrow(real.intersection)) / number.randomisation
bed.intersections[i,1] <- strsplit(x = as.character(combinations[i,1]), split = "_peaks")[[1]][1]
bed.intersections[i,2] <- strsplit(x = as.character(combinations[i,2]), split = "_peaks")[[1]][1]
bed.intersections[i,3] <- p.value
}
i
j
k
peaks2 <- read.table(file = paste0("../../../web_apps/peak_visualizer/data/bed_files/", combinations[i,2]))
peaks1 <- read.table(file = paste0("../../../web_apps/peak_visualizer/data/bed_files/", combinations[i,1]))
real.intersection <- intersectBed(peaks.set1 = peaks1, peaks.set2 = peaks2)
peaks2 <- read.table(file = paste0("../../../web_apps/peak_visualizer/data/bed_files/", combinations[i,2]))
peaks1 <- read.table(file = paste0("../../../web_apps/peak_visualizer/data/bed_files/", combinations[i,1]))
paste0("../../../web_apps/peak_visualizer/data/bed_files/", combinations[i,2])
combinations[i,1]
head(peaks2)
head(peaks1)
real.intersection <- intersectBed(peaks.set1 = peaks1, peaks.set2 = peaks2)
#####Intersections between binding regions in DNA (BED files)####
#Reading the bed files of the transcription factors
peaks1 <- read.table(file = "../../../web_apps/peak_visualizer/data/bed_files/CCA1_ZT02_peaks.narrowPeak")
head(peaks1)
peaks2 <- read.table(file = "../../../web_apps/peak_visualizer/data/bed_files/CCA1_peaks.narrowPeak")
head(peaks2)
peaks.set1 <- peaks1
peaks.set2 <- peaks2
intersection <- matrix(ncol = 3, nrow=0 )
current.intersection <- matrix(ncol = 3 )
#Set the current peak values of set1
current.chr <- peaks.set1[i,1]
current.start <- peaks.set1[i,2]
current.end <- peaks.set1[i,3]
#Checking if there is intersection between the current peak and any peak of set2
option1 <- nrow(subset(peaks.set2, peaks.set2[,1]==current.chr & peaks.set2[,2]<=current.start & peaks.set2[,3]>=current.start))
peaks.set2[,1]==current.chr
current.chr
peaks.set2[,1]
peaks.set2[,1]==current.chr
peaks.set1[i,1]
#Set the current peak values of set1
current.chr <- peaks.set1[i,1][1]
current.chr
peaks.set2[,1]==current.chr
#Set the current peak values of set1
current.chr <- peaks.set1[i,1][[1]]
current.chr
peaks.set2[,1]==current.chr
#Set the current peak values of set1
current.chr <- peaks.set1[i,1][[1]][1]
peaks.set2[,1]==current.chr
peaks.set2[,1]
peaks.set2[,2]<=current.start
current.start
current.chr
peaks.set1[i,1]
#Set the current peak values of set1
current.chr <- peaks.set1[i,1][2]
current.chr
current.chr <- peaks.set1[i,1][1]
current.chr
#Set the current peak values of set1
current.chr <- peaks.set1[i,1][1][[1]]
current.chr
#Set the current peak values of set1
current.chr <- peaks.set1[i,1][1][[2]]
#Set the current peak values of set1
current.chr <- peaks.set1[i,1][1][[1]]
peaks.set2[,1]==current.chr
current.chr <- droplevels(peaks.set1[i,1])
current.chr
peaks.set2[,1]==current.chr
current.chr <- factor(peaks.set1[i,1])
current.chr
peaks.set2[,1]==current.chr
#Set the current peak values of set1
current.chr <- as.numeric(peaks.set1[i,1]))
#Set the current peak values of set1
current.chr <- as.numeric(peaks.set1[i,1])
peaks.set2[,1]==current.chr
current.chr
##Loop to check the intersection of binding regions (bed files) between all the transcription factors together and store the results in a table####
number.randomisation <- 5
bed.files <- list.files(path = "../../../web_apps/peak_visualizer/data/bed_files/", pattern = "peaks.narrowPeak")
combinations <- expand.grid(bed.files, bed.files)
bed.intersections <- matrix(ncol = 5, nrow = nrow(combinations))
colnames(bed.intersections) <- c("TF1", "TF2", "p-value", "fdr", "Genes")
total.randomisation <- number.randomisation*nrow(combinations) #just to see the progress
i <- 5
for (i in 1:nrow(combinations))
{
peaks2 <- read.table(file = paste0("../../../web_apps/peak_visualizer/data/bed_files/", combinations[i,2]))
peaks1 <- read.table(file = paste0("../../../web_apps/peak_visualizer/data/bed_files/", combinations[i,1]))
real.intersection <- intersectBed(peaks.set1 = peaks1, peaks.set2 = peaks2)
random.intersections <- vector(mode = "numeric",length=number.randomisation) #Creating vector
for(j in 1:number.randomisation)
{
print(paste0(((i-1)+j)/total.randomisation, " %"))
random.peaks2 <- matrix(nrow=nrow(peaks2),ncol=3) #Matriz con 3 columnas, una para el cromosoma, otra para el comienzo y otra para el final de la región aleatoria.
for(k in 1:nrow(peaks2))
{
current.chr <- peaks2[k,1][[1]] #Chr de la iésima marca real
current.start <- peaks2[k,2] #Start de la iésima marca real
current.end <- peaks2[k,3] #End de la iésima marca real
current.length <- current.end - current.start #Longitud de la iésima marca real
chr.length <- chromosomes.length[current.chr] #Length del actual cromosoma
#Ahora genero los mismos datos para regiones aleatorias
random.start <- floor(runif(n = 1,min = 1,max = chr.length))
random.end <- random.start + current.length
random.peaks2[k,1] <- current.chr
random.peaks2[k,2] <- random.start
random.peaks2[k,3] <- random.end
}
random.intersections[j] <- nrow(intersectBed(peaks.set1 = peaks1, peaks.set2 = random.peaks2 ))
}
p.value <- sum(random.intersections > nrow(real.intersection)) / number.randomisation
bed.intersections[i,1] <- strsplit(x = as.character(combinations[i,1]), split = "_peaks")[[1]][1]
bed.intersections[i,2] <- strsplit(x = as.character(combinations[i,2]), split = "_peaks")[[1]][1]
bed.intersections[i,3] <- p.value
}
#intersectBed function
intersectBed <- function(peaks.set1, peaks.set2)
{
intersection <- matrix(ncol = 3, nrow=0 )
current.intersection <- matrix(ncol = 3 )
for (i in 1:nrow(peaks.set1))
{
#Set the current peak values of set1
current.chr <- as.numeric(peaks.set1[i,1])
current.start <- peaks.set1[i,2]
current.end <- peaks.set1[i,3]
#Checking if there is intersection between the current peak and any peak of set2
option1 <- nrow(subset(peaks.set2, peaks.set2[,1]==current.chr & peaks.set2[,2]<=current.start & peaks.set2[,3]>=current.start))
option2 <- nrow(subset(peaks.set2, peaks.set2[,1]==current.chr & peaks.set2[,2]<=current.end & peaks.set2[,3]>=current.end))
# print(i)
if(option1+option2 > 0)
{
# print("HIT")
if(option1>0)
{
hit.peak2 <- subset(peaks.set2, peaks.set2[,1]==current.chr & peaks.set2[,2]<=current.start & peaks.set2[,3]>=current.start)
current.intersection[1,1] <- current.chr
current.intersection[1,2] <- current.start
current.intersection[1,3] <- hit.peak2[,3]
}else
{
hit.peak2 <- subset(peaks.set2, peaks.set2[,1]==current.chr & peaks.set2[,2]<=current.end & peaks.set2[,3]>=current.end)
current.intersection[1,1] <- current.chr
current.intersection[1,2] <- hit.peak2[,2]
current.intersection[1,3] <- current.end
}
intersection <- rbind(intersection, current.intersection)
}
}
return(intersection)
}
##Loop to check the intersection of binding regions (bed files) between all the transcription factors together and store the results in a table####
number.randomisation <- 5
bed.files <- list.files(path = "../../../web_apps/peak_visualizer/data/bed_files/", pattern = "peaks.narrowPeak")
combinations <- expand.grid(bed.files, bed.files)
bed.intersections <- matrix(ncol = 5, nrow = nrow(combinations))
colnames(bed.intersections) <- c("TF1", "TF2", "p-value", "fdr", "Genes")
total.randomisation <- number.randomisation*nrow(combinations) #just to see the progress
i <- 5
for (i in 1:nrow(combinations))
{
peaks2 <- read.table(file = paste0("../../../web_apps/peak_visualizer/data/bed_files/", combinations[i,2]))
peaks1 <- read.table(file = paste0("../../../web_apps/peak_visualizer/data/bed_files/", combinations[i,1]))
real.intersection <- intersectBed(peaks.set1 = peaks1, peaks.set2 = peaks2)
random.intersections <- vector(mode = "numeric",length=number.randomisation) #Creating vector
for(j in 1:number.randomisation)
{
print(paste0(((i-1)+j)/total.randomisation, " %"))
random.peaks2 <- matrix(nrow=nrow(peaks2),ncol=3) #Matriz con 3 columnas, una para el cromosoma, otra para el comienzo y otra para el final de la región aleatoria.
for(k in 1:nrow(peaks2))
{
current.chr <- peaks2[k,1][[1]] #Chr de la iésima marca real
current.start <- peaks2[k,2] #Start de la iésima marca real
current.end <- peaks2[k,3] #End de la iésima marca real
current.length <- current.end - current.start #Longitud de la iésima marca real
chr.length <- chromosomes.length[current.chr] #Length del actual cromosoma
#Ahora genero los mismos datos para regiones aleatorias
random.start <- floor(runif(n = 1,min = 1,max = chr.length))
random.end <- random.start + current.length
random.peaks2[k,1] <- current.chr
random.peaks2[k,2] <- random.start
random.peaks2[k,3] <- random.end
}
random.intersections[j] <- nrow(intersectBed(peaks.set1 = peaks1, peaks.set2 = random.peaks2 ))
}
p.value <- sum(random.intersections > nrow(real.intersection)) / number.randomisation
bed.intersections[i,1] <- strsplit(x = as.character(combinations[i,1]), split = "_peaks")[[1]][1]
bed.intersections[i,2] <- strsplit(x = as.character(combinations[i,2]), split = "_peaks")[[1]][1]
bed.intersections[i,3] <- p.value
}
number.randomisation <- 5
bed.files <- list.files(path = "../../../web_apps/peak_visualizer/data/bed_files/", pattern = "peaks.narrowPeak")
combinations <- expand.grid(bed.files, bed.files)
bed.intersections <- matrix(ncol = 5, nrow = nrow(combinations))
colnames(bed.intersections) <- c("TF1", "TF2", "p-value", "fdr", "Genes")
total.randomisation <- number.randomisation*nrow(combinations) #just to see the progress
i <- 5
for (i in 1:nrow(combinations))
{
peaks2 <- read.table(file = paste0("../../../web_apps/peak_visualizer/data/bed_files/", combinations[i,2]))
peaks1 <- read.table(file = paste0("../../../web_apps/peak_visualizer/data/bed_files/", combinations[i,1]))
real.intersection <- intersectBed(peaks.set1 = peaks1, peaks.set2 = peaks2)
random.intersections <- vector(mode = "numeric",length=number.randomisation) #Creating vector
for(j in 1:number.randomisation)
{
print(paste0((((i-1)*number.randomisation)+j)/total.randomisation, " %"))
random.peaks2 <- matrix(nrow=nrow(peaks2),ncol=3) #Matriz con 3 columnas, una para el cromosoma, otra para el comienzo y otra para el final de la región aleatoria.
for(k in 1:nrow(peaks2))
{
current.chr <- peaks2[k,1][[1]] #Chr de la iésima marca real
current.start <- peaks2[k,2] #Start de la iésima marca real
current.end <- peaks2[k,3] #End de la iésima marca real
current.length <- current.end - current.start #Longitud de la iésima marca real
chr.length <- chromosomes.length[current.chr] #Length del actual cromosoma
#Ahora genero los mismos datos para regiones aleatorias
random.start <- floor(runif(n = 1,min = 1,max = chr.length))
random.end <- random.start + current.length
random.peaks2[k,1] <- current.chr
random.peaks2[k,2] <- random.start
random.peaks2[k,3] <- random.end
}
random.intersections[j] <- nrow(intersectBed(peaks.set1 = peaks1, peaks.set2 = random.peaks2 ))
}
p.value <- sum(random.intersections > nrow(real.intersection)) / number.randomisation
bed.intersections[i,1] <- strsplit(x = as.character(combinations[i,1]), split = "_peaks")[[1]][1]
bed.intersections[i,2] <- strsplit(x = as.character(combinations[i,2]), split = "_peaks")[[1]][1]
bed.intersections[i,3] <- p.value
}
i
j
k
combinations[i,2]
combinations[i,1]
peaks1 <- read.table(file = paste0("../../../web_apps/peak_visualizer/data/bed_files/", combinations[i,1]))
peaks2 <- read.table(file = paste0("../../../web_apps/peak_visualizer/data/bed_files/", combinations[i,2]))
peaks.set1 <- peaks1
peaks.set2 <- peaks2
intersection <- matrix(ncol = 3, nrow=0 )
current.intersection <- matrix(ncol = 3 )
#Set the current peak values of set1
current.chr <- as.numeric(peaks.set1[i,1])
current.start <- peaks.set1[i,2]
current.end <- peaks.set1[i,3]
#Checking if there is intersection between the current peak and any peak of set2
option1 <- nrow(subset(peaks.set2, peaks.set2[,1]==current.chr & peaks.set2[,2]<=current.start & peaks.set2[,3]>=current.start))
option2 <- nrow(subset(peaks.set2, peaks.set2[,1]==current.chr & peaks.set2[,2]<=current.end & peaks.set2[,3]>=current.end))
option1
option2
#intersectBed function
intersectBed <- function(peaks.set1, peaks.set2)
{
intersection <- matrix(ncol = 3, nrow=0 )
current.intersection <- matrix(ncol = 3 )
for (i in 1:nrow(peaks.set1))
{
#Set the current peak values of set1
current.chr <- as.numeric(peaks.set1[i,1])
current.start <- peaks.set1[i,2]
current.end <- peaks.set1[i,3]
#Checking if there is intersection between the current peak and any peak of set2
option1 <- nrow(subset(peaks.set2, peaks.set2[,1]==current.chr & peaks.set2[,2]<=current.start & peaks.set2[,3]>=current.start))
option2 <- nrow(subset(peaks.set2, peaks.set2[,1]==current.chr & peaks.set2[,2]<=current.end & peaks.set2[,3]>=current.end))
# print(i)
if(option1+option2 > 0)
{
# print("HIT")
if(option1>0)
{
hit.peak2 <- subset(peaks.set2, peaks.set2[,1]==current.chr & peaks.set2[,2]<=current.start & peaks.set2[,3]>=current.start)
current.intersection[1,1] <- current.chr
current.intersection[1,2] <- current.start
current.intersection[1,3] <- hit.peak2[,3]
}else
{
hit.peak2 <- subset(peaks.set2, peaks.set2[,1]==current.chr & peaks.set2[,2]<=current.end & peaks.set2[,3]>=current.end)
current.intersection[1,1] <- current.chr
current.intersection[1,2] <- hit.peak2[,2]
current.intersection[1,3] <- current.end
}
intersection <- rbind(intersection, current.intersection)
}
}
return(intersection)
}
intersection
nrow(intersectBed(peaks.set1 = peaks1, peaks.set2 = random.peaks2 ))
nrow(real.intersection)
i
j
combinations[i,1]
combinations[i,2]
real.intersection <- intersectBed(peaks.set1 = peaks1, peaks.set2 = peaks2)
real.intersection
print(paste0((((i-1)*number.randomisation)+j)/total.randomisation, " %"))
random.peaks2 <- matrix(nrow=nrow(peaks2),ncol=3) #Matriz con 3 columnas, una para el cromosoma, otra para el comienzo y otra para el final de la región aleatoria.
k
current.chr <- peaks2[k,1][[1]] #Chr de la iésima marca real
current.chr
current.start <- peaks2[k,2] #Start de la iésima marca real
current.start <- peaks2[k,2] #Start de la iésima marca real
current.end <- peaks2[k,3] #End de la iésima marca real
current.length <- current.end - current.start #Longitud de la iésima marca real
current.start
current.end
current.length
chr.length
chr.length <- chromosomes.length[current.chr] #Length del actual cromosoma
chr.length
#Ahora genero los mismos datos para regiones aleatorias
random.start <- floor(runif(n = 1,min = 1,max = chr.length))
current.chr
number.randomisation <- 5
bed.files <- list.files(path = "../../../web_apps/peak_visualizer/data/bed_files/", pattern = "peaks.narrowPeak")
combinations <- expand.grid(bed.files, bed.files)
bed.intersections <- matrix(ncol = 5, nrow = nrow(combinations))
colnames(bed.intersections) <- c("TF1", "TF2", "p-value", "fdr", "Genes")
total.randomisation <- number.randomisation*nrow(combinations) #just to see the progress
i <- 5
for (i in 1:nrow(combinations))
{
peaks1 <- read.table(file = paste0("../../../web_apps/peak_visualizer/data/bed_files/", combinations[i,1]))
peaks2 <- read.table(file = paste0("../../../web_apps/peak_visualizer/data/bed_files/", combinations[i,2]))
real.intersection <- intersectBed(peaks.set1 = peaks1, peaks.set2 = peaks2)
random.intersections <- vector(mode = "numeric",length=number.randomisation) #Creating vector
for(j in 1:number.randomisation)
{
print(paste0((((i-1)*number.randomisation)+j)/total.randomisation, " %"))
random.peaks2 <- matrix(nrow=nrow(peaks2),ncol=3) #Matriz con 3 columnas, una para el cromosoma, otra para el comienzo y otra para el final de la región aleatoria.
for(k in 1:nrow(peaks2))
{
current.chr <- peaks2[k,1][[1]] #Chr de la iésima marca real
current.start <- peaks2[k,2] #Start de la iésima marca real
current.end <- peaks2[k,3] #End de la iésima marca real
current.length <- current.end - current.start #Longitud de la iésima marca real
chr.length <- chromosomes.length[current.chr] #Length del actual cromosoma
#Ahora genero los mismos datos para regiones aleatorias
random.start <- floor(runif(n = 1,min = 1,max = chr.length))
random.end <- random.start + current.length
random.peaks2[k,1] <- current.chr
random.peaks2[k,2] <- random.start
random.peaks2[k,3] <- random.end
}
random.intersections[j] <- nrow(intersectBed(peaks.set1 = peaks1, peaks.set2 = random.peaks2 ))
}
p.value <- sum(random.intersections > nrow(real.intersection)) / number.randomisation
bed.intersections[i,1] <- strsplit(x = as.character(combinations[i,1]), split = "_peaks")[[1]][1]
bed.intersections[i,2] <- strsplit(x = as.character(combinations[i,2]), split = "_peaks")[[1]][1]
bed.intersections[i,3] <- p.value
}
i
j
k
combinations[i,1]
combinations[i,2]
current.chr <- peaks2[k,1][[1]] #Chr de la iésima marca real
current.chr
current.start <- peaks2[k,2] #Start de la iésima marca real
current.end <- peaks2[k,3] #End de la iésima marca real
current.length <- current.end - current.start #Longitud de la iésima marca real
chr.length <- chromosomes.length[current.chr] #Length del actual cromosoma
#Ahora genero los mismos datos para regiones aleatorias
random.start <- floor(runif(n = 1,min = 1,max = chr.length))
random.end <- random.start + current.length
random.peaks2[k,1] <- current.chr
random.peaks2[k,2] <- random.start
random.peaks2[k,3] <- random.end
random.start
random.end
##Loop to check the intersection of binding regions (bed files) between all the transcription factors together and store the results in a table####
number.randomisation <- 5
bed.files <- list.files(path = "../../../web_apps/peak_visualizer/data/bed_files/", pattern = "peaks.narrowPeak")
combinations <- expand.grid(bed.files, bed.files)
bed.intersections <- matrix(ncol = 5, nrow = nrow(combinations))
colnames(bed.intersections) <- c("TF1", "TF2", "p-value", "fdr", "Genes")
total.randomisation <- number.randomisation*nrow(combinations) #just to see the progress
i <- 5
for (i in 1:nrow(combinations))
{
peaks1 <- read.table(file = paste0("../../../web_apps/peak_visualizer/data/bed_files/", combinations[i,1]))
peaks2 <- read.table(file = paste0("../../../web_apps/peak_visualizer/data/bed_files/", combinations[i,2]))
real.intersection <- intersectBed(peaks.set1 = peaks1, peaks.set2 = peaks2)
random.intersections <- vector(mode = "numeric",length=number.randomisation) #Creating vector
for(j in 1:number.randomisation)
{
print(paste0((((i-1)*number.randomisation)+j)/total.randomisation, " %"))
random.peaks2 <- matrix(nrow=nrow(peaks2),ncol=3) #Matriz con 3 columnas, una para el cromosoma, otra para el comienzo y otra para el final de la región aleatoria.
for(k in 1:nrow(peaks2))
{
current.chr <- peaks2[k,1][[1]] #Chr de la iésima marca real
current.start <- peaks2[k,2] #Start de la iésima marca real
current.end <- peaks2[k,3] #End de la iésima marca real
current.length <- current.end - current.start #Longitud de la iésima marca real
chr.length <- chromosomes.length[current.chr] #Length del actual cromosoma
#Ahora genero los mismos datos para regiones aleatorias
random.start <- floor(runif(n = 1,min = 1,max = chr.length))
random.end <- random.start + current.length
random.peaks2[k,1] <- current.chr
random.peaks2[k,2] <- random.start
random.peaks2[k,3] <- random.end
}
random.intersections[j] <- nrow(intersectBed(peaks.set1 = peaks1, peaks.set2 = random.peaks2 ))
}
p.value <- sum(random.intersections > nrow(real.intersection)) / number.randomisation
bed.intersections[i,1] <- strsplit(x = as.character(combinations[i,1]), split = "_peaks")[[1]][1]
bed.intersections[i,2] <- strsplit(x = as.character(combinations[i,2]), split = "_peaks")[[1]][1]
bed.intersections[i,3] <- p.value
}
i
j
k
combinations[i,2]
