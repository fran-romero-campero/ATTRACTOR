# for (i in 1:nrow(combinations))
{
print(paste0("combination number ", i, " of ", nrow(combinations)))
peaks1 <- read.table(file = paste0("../../../web_apps/peak_visualizer/data/bed_files/", combinations[i,1]))
peaks2 <- read.table(file = paste0("../../../web_apps/peak_visualizer/data/bed_files/", combinations[i,2]))
real.intersection <- intersectBed(peaks.set1 = peaks1, peaks.set2 = peaks2)
random.intersections <- vector(mode = "numeric",length=number.randomisation) #Creating vector
for(j in 1:number.randomisation)
{
random.peaks2 <- matrix(nrow=nrow(peaks2),ncol=3) #Matriz con 3 columnas, una para el cromosoma, otra para el comienzo y otra para el final de la región aleatoria.
for(k in 1:nrow(peaks2))
{
current.chr <- peaks2[k,1][[1]] #Chr de la iésima marca real
current.start <- peaks2[k,2] #Start de la iésima marca real
current.end <- peaks2[k,3] #End de la iésima marca real
current.length <- current.end - current.start #Longitud de la iésima marca real
chr.length <- chromosomes.length[current.chr] #Length del actual cromosoma
#Ahora genero los mismos datos para regiones aleatorias
random.start <- floor(runif(n = 1,min = 1,max = chr.length))
random.end <- random.start + current.length
random.peaks2[k,1] <- current.chr
random.peaks2[k,2] <- random.start
random.peaks2[k,3] <- random.end
}
random.intersections[j] <- nrow(intersectBed(peaks.set1 = peaks1, peaks.set2 = random.peaks2 ))
}
p.value <- sum(random.intersections > nrow(real.intersection)) / number.randomisation
colnames(real.intersection) <- c("chromosome", "start", "end")
granges.intersection <- makeGRangesFromDataFrame(real.intersection,
keep.extra.columns=FALSE,
ignore.strand=FALSE,
seqinfo=NULL,
seqnames.field="chromosome",
start.field="start",
end.field="end",
starts.in.df.are.0based=FALSE)
peakAnno <- annotatePeak(granges.intersection, tssRegion=c(-2000, 2000),
TxDb=txdb, annoDb="org.At.tair.db")
annot.peaks <- as.data.frame(peakAnno)
target.genes <- subset(annot.peaks, distanceToTSS >= 2000 | distanceToTSS <= -2000)$geneId
target.genes <- paste(target.genes, collapse = ",")
bed.intersections[i,1] <- strsplit(x = as.character(combinations[i,1]), split = "_peaks")[[1]][1]
bed.intersections[i,2] <- strsplit(x = as.character(combinations[i,2]), split = "_peaks")[[1]][1]
bed.intersections[i,3] <- p.value
bed.intersections[i,5] <- nrow(real.intersection)
bed.intersections[i,6] <- target.genes
}
for (i in 1:5)
# for (i in 1:nrow(combinations))
{
print(paste0("test number ", i, " of ", nrow(combinations)))
peaks1 <- read.table(file = paste0("../../../web_apps/peak_visualizer/data/bed_files/", combinations[i,1]))
peaks2 <- read.table(file = paste0("../../../web_apps/peak_visualizer/data/bed_files/", combinations[i,2]))
real.intersection <- intersectBed(peaks.set1 = peaks1, peaks.set2 = peaks2)
random.intersections <- vector(mode = "numeric",length=number.randomisation) #Creating vector
for(j in 1:number.randomisation)
{
random.peaks2 <- matrix(nrow=nrow(peaks2),ncol=3) #Matriz con 3 columnas, una para el cromosoma, otra para el comienzo y otra para el final de la región aleatoria.
for(k in 1:nrow(peaks2))
{
current.chr <- peaks2[k,1][[1]] #Chr de la iésima marca real
current.start <- peaks2[k,2] #Start de la iésima marca real
current.end <- peaks2[k,3] #End de la iésima marca real
current.length <- current.end - current.start #Longitud de la iésima marca real
chr.length <- chromosomes.length[current.chr] #Length del actual cromosoma
#Ahora genero los mismos datos para regiones aleatorias
random.start <- floor(runif(n = 1,min = 1,max = chr.length))
random.end <- random.start + current.length
random.peaks2[k,1] <- current.chr
random.peaks2[k,2] <- random.start
random.peaks2[k,3] <- random.end
}
random.intersections[j] <- nrow(intersectBed(peaks.set1 = peaks1, peaks.set2 = random.peaks2 ))
}
p.value <- sum(random.intersections > nrow(real.intersection)) / number.randomisation
colnames(real.intersection) <- c("chromosome", "start", "end")
granges.intersection <- makeGRangesFromDataFrame(real.intersection,
keep.extra.columns=FALSE,
ignore.strand=FALSE,
seqinfo=NULL,
seqnames.field="chromosome",
start.field="start",
end.field="end",
starts.in.df.are.0based=FALSE)
peakAnno <- annotatePeak(granges.intersection, tssRegion=c(-2000, 2000),
TxDb=txdb, annoDb="org.At.tair.db")
annot.peaks <- as.data.frame(peakAnno)
target.genes <- subset(annot.peaks, distanceToTSS >= 2000 | distanceToTSS <= -2000)$geneId
target.genes <- paste(target.genes, collapse = ",")
bed.intersections[i,1] <- strsplit(x = as.character(combinations[i,1]), split = "_peaks")[[1]][1]
bed.intersections[i,2] <- strsplit(x = as.character(combinations[i,2]), split = "_peaks")[[1]][1]
bed.intersections[i,3] <- p.value
bed.intersections[i,5] <- nrow(real.intersection)
bed.intersections[i,6] <- target.genes
}
write.table(bed.intersections, file = "bed_intersections.txt", sep = "\t", row.names = FALSE)
##Loop to check the intersection of binding regions (bed files) between all the transcription factors together and store the results in a table####
chromosomes.length <- read.table(file="../../../web_apps/peak_visualizer/data/bed_files/atha_chr_lengths.txt",as.is=T)[[1]]
number.randomisation <- 5
bed.files <- list.files(path = "../../../web_apps/peak_visualizer/data/bed_files/", pattern = "peaks.narrowPeak")
combinations <- expand.grid(bed.files, bed.files)
bed.intersections <- matrix(ncol = 6, nrow = nrow(combinations))
colnames(bed.intersections) <- c("TF1", "TF2", "p-value", "fdr", "number of intersections", "Genes" )
total.randomisation <- number.randomisation*nrow(combinations) #just to see the progress
txdb <- TxDb.Athaliana.BioMart.plantsmart28
i <- 9
for (i in 1:5)
# for (i in 1:nrow(combinations))
{
print(paste0("test number ", i, " of ", nrow(combinations)))
peaks1 <- read.table(file = paste0("../../../web_apps/peak_visualizer/data/bed_files/", combinations[i,1]))
peaks2 <- read.table(file = paste0("../../../web_apps/peak_visualizer/data/bed_files/", combinations[i,2]))
real.intersection <- intersectBed(peaks.set1 = peaks1, peaks.set2 = peaks2)
random.intersections <- vector(mode = "numeric",length=number.randomisation) #Creating vector
for(j in 1:number.randomisation)
{
random.peaks2 <- matrix(nrow=nrow(peaks2),ncol=3) #Matriz con 3 columnas, una para el cromosoma, otra para el comienzo y otra para el final de la región aleatoria.
for(k in 1:nrow(peaks2))
{
current.chr <- peaks2[k,1][[1]] #Chr de la iésima marca real
current.start <- peaks2[k,2] #Start de la iésima marca real
current.end <- peaks2[k,3] #End de la iésima marca real
current.length <- current.end - current.start #Longitud de la iésima marca real
chr.length <- chromosomes.length[current.chr] #Length del actual cromosoma
#Ahora genero los mismos datos para regiones aleatorias
random.start <- floor(runif(n = 1,min = 1,max = chr.length))
random.end <- random.start + current.length
random.peaks2[k,1] <- current.chr
random.peaks2[k,2] <- random.start
random.peaks2[k,3] <- random.end
}
random.intersections[j] <- nrow(intersectBed(peaks.set1 = peaks1, peaks.set2 = random.peaks2 ))
}
p.value <- sum(random.intersections > nrow(real.intersection)) / number.randomisation
colnames(real.intersection) <- c("chromosome", "start", "end")
granges.intersection <- makeGRangesFromDataFrame(real.intersection,
keep.extra.columns=FALSE,
ignore.strand=FALSE,
seqinfo=NULL,
seqnames.field="chromosome",
start.field="start",
end.field="end",
starts.in.df.are.0based=FALSE)
peakAnno <- annotatePeak(granges.intersection, tssRegion=c(-2000, 2000),
TxDb=txdb, annoDb="org.At.tair.db")
annot.peaks <- as.data.frame(peakAnno)
target.genes <- subset(annot.peaks, distanceToTSS >= 2000 | distanceToTSS <= -2000)$geneId
target.genes <- paste(target.genes, collapse = ",")
bed.intersections[i,1] <- strsplit(x = as.character(combinations[i,1]), split = "_peaks")[[1]][1]
bed.intersections[i,2] <- strsplit(x = as.character(combinations[i,2]), split = "_peaks")[[1]][1]
bed.intersections[i,3] <- p.value
bed.intersections[i,5] <- nrow(real.intersection)
bed.intersections[i,6] <- target.genes
}
write.table(bed.intersections, file = "bed_intersections.txt", sep = "\t", row.names = FALSE)
print(paste0(i/nrow(combinations), " %"))
i
print(paste0((i/nrow(combinations))*10, " %"))
print(paste0((i/nrow(combinations))*100, " %"))
# for (i in 1:5)
for (i in 1:nrow(combinations))
{
# print(paste0("test number ", i, " of ", nrow(combinations)))
print(paste0((i/nrow(combinations))*100, " %"))
peaks1 <- read.table(file = paste0("../../../web_apps/peak_visualizer/data/bed_files/", combinations[i,1]))
peaks2 <- read.table(file = paste0("../../../web_apps/peak_visualizer/data/bed_files/", combinations[i,2]))
real.intersection <- intersectBed(peaks.set1 = peaks1, peaks.set2 = peaks2)
random.intersections <- vector(mode = "numeric",length=number.randomisation) #Creating vector
for(j in 1:number.randomisation)
{
random.peaks2 <- matrix(nrow=nrow(peaks2),ncol=3) #Matriz con 3 columnas, una para el cromosoma, otra para el comienzo y otra para el final de la región aleatoria.
for(k in 1:nrow(peaks2))
{
current.chr <- peaks2[k,1][[1]] #Chr de la iésima marca real
current.start <- peaks2[k,2] #Start de la iésima marca real
current.end <- peaks2[k,3] #End de la iésima marca real
current.length <- current.end - current.start #Longitud de la iésima marca real
chr.length <- chromosomes.length[current.chr] #Length del actual cromosoma
#Ahora genero los mismos datos para regiones aleatorias
random.start <- floor(runif(n = 1,min = 1,max = chr.length))
random.end <- random.start + current.length
random.peaks2[k,1] <- current.chr
random.peaks2[k,2] <- random.start
random.peaks2[k,3] <- random.end
}
random.intersections[j] <- nrow(intersectBed(peaks.set1 = peaks1, peaks.set2 = random.peaks2 ))
}
p.value <- sum(random.intersections > nrow(real.intersection)) / number.randomisation
colnames(real.intersection) <- c("chromosome", "start", "end")
granges.intersection <- makeGRangesFromDataFrame(real.intersection,
keep.extra.columns=FALSE,
ignore.strand=FALSE,
seqinfo=NULL,
seqnames.field="chromosome",
start.field="start",
end.field="end",
starts.in.df.are.0based=FALSE)
peakAnno <- annotatePeak(granges.intersection, tssRegion=c(-2000, 2000),
TxDb=txdb, annoDb="org.At.tair.db")
annot.peaks <- as.data.frame(peakAnno)
target.genes <- subset(annot.peaks, distanceToTSS >= 2000 | distanceToTSS <= -2000)$geneId
target.genes <- paste(target.genes, collapse = ",")
bed.intersections[i,1] <- strsplit(x = as.character(combinations[i,1]), split = "_peaks")[[1]][1]
bed.intersections[i,2] <- strsplit(x = as.character(combinations[i,2]), split = "_peaks")[[1]][1]
bed.intersections[i,3] <- p.value
bed.intersections[i,5] <- nrow(real.intersection)
bed.intersections[i,6] <- target.genes
}
write.table(bed.intersections, file = "bed_intersections.txt", sep = "\t", row.names = FALSE)
chromosomes.length <- read.table(file="../../../web_apps/peak_visualizer/data/bed_files/atha_chr_lengths.txt",as.is=T)[[1]]
number.randomisation <- 1000
bed.files <- list.files(path = "../../../web_apps/peak_visualizer/data/bed_files/", pattern = "peaks.narrowPeak")
combinations <- expand.grid(bed.files, bed.files)
bed.intersections <- matrix(ncol = 6, nrow = nrow(combinations))
colnames(bed.intersections) <- c("TF1", "TF2", "p-value", "fdr", "number of intersections", "Genes" )
txdb <- TxDb.Athaliana.BioMart.plantsmart28
i <- 9
# Start the clock!
ptm <- proc.time()
# for (i in 1:5)
for (i in 1:nrow(combinations))
{
# print(paste0("test number ", i, " of ", nrow(combinations)))
print(paste0((i/nrow(combinations))*100, " %"))
peaks1 <- read.table(file = paste0("../../../web_apps/peak_visualizer/data/bed_files/", combinations[i,1]))
peaks2 <- read.table(file = paste0("../../../web_apps/peak_visualizer/data/bed_files/", combinations[i,2]))
real.intersection <- intersectBed(peaks.set1 = peaks1, peaks.set2 = peaks2)
random.intersections <- vector(mode = "numeric",length=number.randomisation) #Creating vector
for(j in 1:number.randomisation)
{
random.peaks2 <- matrix(nrow=nrow(peaks2),ncol=3) #Matriz con 3 columnas, una para el cromosoma, otra para el comienzo y otra para el final de la región aleatoria.
for(k in 1:nrow(peaks2))
{
current.chr <- peaks2[k,1][[1]] #Chr de la iésima marca real
current.start <- peaks2[k,2] #Start de la iésima marca real
current.end <- peaks2[k,3] #End de la iésima marca real
current.length <- current.end - current.start #Longitud de la iésima marca real
chr.length <- chromosomes.length[current.chr] #Length del actual cromosoma
#Ahora genero los mismos datos para regiones aleatorias
random.start <- floor(runif(n = 1,min = 1,max = chr.length))
random.end <- random.start + current.length
random.peaks2[k,1] <- current.chr
random.peaks2[k,2] <- random.start
random.peaks2[k,3] <- random.end
}
random.intersections[j] <- nrow(intersectBed(peaks.set1 = peaks1, peaks.set2 = random.peaks2 ))
}
p.value <- sum(random.intersections > nrow(real.intersection)) / number.randomisation
colnames(real.intersection) <- c("chromosome", "start", "end")
granges.intersection <- makeGRangesFromDataFrame(real.intersection,
keep.extra.columns=FALSE,
ignore.strand=FALSE,
seqinfo=NULL,
seqnames.field="chromosome",
start.field="start",
end.field="end",
starts.in.df.are.0based=FALSE)
peakAnno <- annotatePeak(granges.intersection, tssRegion=c(-2000, 2000),
TxDb=txdb, annoDb="org.At.tair.db")
annot.peaks <- as.data.frame(peakAnno)
target.genes <- subset(annot.peaks, distanceToTSS >= 2000 | distanceToTSS <= -2000)$geneId
target.genes <- paste(target.genes, collapse = ",")
bed.intersections[i,1] <- strsplit(x = as.character(combinations[i,1]), split = "_peaks")[[1]][1]
bed.intersections[i,2] <- strsplit(x = as.character(combinations[i,2]), split = "_peaks")[[1]][1]
bed.intersections[i,3] <- p.value
bed.intersections[i,5] <- nrow(real.intersection)
bed.intersections[i,6] <- target.genes
}
proc.time() - ptm
peaks1 <- read.table(file = "../../../web_apps/peak_visualizer/data/bed_files/CCA1_ZT02_peaks.narrowPeak")
head(peaks1)
peaks2 <- read.table(file = "../../../web_apps/peak_visualizer/data/bed_files/CCA1_peaks.narrowPeak")
head(peaks2)
peaks.list <- list(peaks1, peaks2)
findOverlapsOfPeaks(peaks.list)
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("genomation", version = "3.8")
findOverlapsOfPeaks(peaks.list)
library(genomation)
findOverlapsOfPeaks(peaks.list)
library(ChIPpeakAnno)
findOverlapsOfPeaks(peaks.list)
for (i in 1:4)
# for (i in 1:nrow(combinations))
{
# print(paste0("test number ", i, " of ", nrow(combinations)))
print(paste0((i/nrow(combinations))*100, " %"))
peaks1 <- read.table(file = paste0("../../../web_apps/peak_visualizer/data/bed_files/", combinations[i,1]))
peaks2 <- read.table(file = paste0("../../../web_apps/peak_visualizer/data/bed_files/", combinations[i,2]))
real.intersection <- intersectBed(peaks.set1 = peaks1, peaks.set2 = peaks2)
random.intersections <- vector(mode = "numeric",length=number.randomisation) #Creating vector
for(j in 1:number.randomisation)
{
print(j)
random.peaks2 <- matrix(nrow=nrow(peaks2),ncol=3) #Matriz con 3 columnas, una para el cromosoma, otra para el comienzo y otra para el final de la región aleatoria.
for(k in 1:nrow(peaks2))
{
current.chr <- peaks2[k,1][[1]] #Chr de la iésima marca real
current.start <- peaks2[k,2] #Start de la iésima marca real
current.end <- peaks2[k,3] #End de la iésima marca real
current.length <- current.end - current.start #Longitud de la iésima marca real
chr.length <- chromosomes.length[current.chr] #Length del actual cromosoma
#Ahora genero los mismos datos para regiones aleatorias
random.start <- floor(runif(n = 1,min = 1,max = chr.length))
random.end <- random.start + current.length
random.peaks2[k,1] <- current.chr
random.peaks2[k,2] <- random.start
random.peaks2[k,3] <- random.end
}
random.intersections[j] <- nrow(intersectBed(peaks.set1 = peaks1, peaks.set2 = random.peaks2 ))
}
p.value <- sum(random.intersections > nrow(real.intersection)) / number.randomisation
colnames(real.intersection) <- c("chromosome", "start", "end")
granges.intersection <- makeGRangesFromDataFrame(real.intersection,
keep.extra.columns=FALSE,
ignore.strand=FALSE,
seqinfo=NULL,
seqnames.field="chromosome",
start.field="start",
end.field="end",
starts.in.df.are.0based=FALSE)
peakAnno <- annotatePeak(granges.intersection, tssRegion=c(-2000, 2000),
TxDb=txdb, annoDb="org.At.tair.db")
annot.peaks <- as.data.frame(peakAnno)
target.genes <- subset(annot.peaks, distanceToTSS >= 2000 | distanceToTSS <= -2000)$geneId
target.genes <- paste(target.genes, collapse = ",")
bed.intersections[i,1] <- strsplit(x = as.character(combinations[i,1]), split = "_peaks")[[1]][1]
bed.intersections[i,2] <- strsplit(x = as.character(combinations[i,2]), split = "_peaks")[[1]][1]
bed.intersections[i,3] <- p.value
bed.intersections[i,5] <- nrow(real.intersection)
bed.intersections[i,6] <- target.genes
}
##Loop to check the intersection of binding regions (bed files) between all the transcription factors together and store the results in a table####
chromosomes.length <- read.table(file="../../../web_apps/peak_visualizer/data/bed_files/atha_chr_lengths.txt",as.is=T)[[1]]
number.randomisation <- 100
bed.files <- list.files(path = "../../../web_apps/peak_visualizer/data/bed_files/", pattern = "peaks.narrowPeak")
combinations <- expand.grid(bed.files, bed.files)
bed.intersections <- matrix(ncol = 6, nrow = nrow(combinations))
colnames(bed.intersections) <- c("TF1", "TF2", "p-value", "fdr", "number of intersections", "Genes" )
txdb <- TxDb.Athaliana.BioMart.plantsmart28
i <- 9
# Start the clock!
ptm <- proc.time()
for (i in 1:4)
# for (i in 1:nrow(combinations))
{
# print(paste0("test number ", i, " of ", nrow(combinations)))
print(paste0((i/nrow(combinations))*100, " %"))
peaks1 <- read.table(file = paste0("../../../web_apps/peak_visualizer/data/bed_files/", combinations[i,1]))
peaks2 <- read.table(file = paste0("../../../web_apps/peak_visualizer/data/bed_files/", combinations[i,2]))
real.intersection <- intersectBed(peaks.set1 = peaks1, peaks.set2 = peaks2)
random.intersections <- vector(mode = "numeric",length=number.randomisation) #Creating vector
for(j in 1:number.randomisation)
{
# print(j)
random.peaks2 <- matrix(nrow=nrow(peaks2),ncol=3) #Matriz con 3 columnas, una para el cromosoma, otra para el comienzo y otra para el final de la región aleatoria.
for(k in 1:nrow(peaks2))
{
current.chr <- peaks2[k,1][[1]] #Chr de la iésima marca real
current.start <- peaks2[k,2] #Start de la iésima marca real
current.end <- peaks2[k,3] #End de la iésima marca real
current.length <- current.end - current.start #Longitud de la iésima marca real
chr.length <- chromosomes.length[current.chr] #Length del actual cromosoma
#Ahora genero los mismos datos para regiones aleatorias
random.start <- floor(runif(n = 1,min = 1,max = chr.length))
random.end <- random.start + current.length
random.peaks2[k,1] <- current.chr
random.peaks2[k,2] <- random.start
random.peaks2[k,3] <- random.end
}
random.intersections[j] <- nrow(intersectBed(peaks.set1 = peaks1, peaks.set2 = random.peaks2 ))
}
p.value <- sum(random.intersections > nrow(real.intersection)) / number.randomisation
colnames(real.intersection) <- c("chromosome", "start", "end")
granges.intersection <- makeGRangesFromDataFrame(real.intersection,
keep.extra.columns=FALSE,
ignore.strand=FALSE,
seqinfo=NULL,
seqnames.field="chromosome",
start.field="start",
end.field="end",
starts.in.df.are.0based=FALSE)
peakAnno <- annotatePeak(granges.intersection, tssRegion=c(-2000, 2000),
TxDb=txdb, annoDb="org.At.tair.db")
annot.peaks <- as.data.frame(peakAnno)
target.genes <- subset(annot.peaks, distanceToTSS >= 2000 | distanceToTSS <= -2000)$geneId
target.genes <- paste(target.genes, collapse = ",")
bed.intersections[i,1] <- strsplit(x = as.character(combinations[i,1]), split = "_peaks")[[1]][1]
bed.intersections[i,2] <- strsplit(x = as.character(combinations[i,2]), split = "_peaks")[[1]][1]
bed.intersections[i,3] <- p.value
bed.intersections[i,5] <- nrow(real.intersection)
bed.intersections[i,6] <- target.genes
}
# Start the clock!
ptm <- proc.time()
for (i in 1:4)
# for (i in 1:nrow(combinations))
{
# print(paste0("test number ", i, " of ", nrow(combinations)))
print(paste0((i/nrow(combinations))*100, " %"))
peaks1 <- read.table(file = paste0("../../../web_apps/peak_visualizer/data/bed_files/", combinations[i,1]))
peaks2 <- read.table(file = paste0("../../../web_apps/peak_visualizer/data/bed_files/", combinations[i,2]))
real.intersection <- intersectBed(peaks.set1 = peaks1, peaks.set2 = peaks2)
random.intersections <- vector(mode = "numeric",length=number.randomisation) #Creating vector
for(j in 1:number.randomisation)
{
# print(j)
random.peaks2 <- matrix(nrow=nrow(peaks2),ncol=3) #Matriz con 3 columnas, una para el cromosoma, otra para el comienzo y otra para el final de la región aleatoria.
for(k in 1:nrow(peaks2))
{
current.chr <- peaks2[k,1][[1]] #Chr de la iésima marca real
current.start <- peaks2[k,2] #Start de la iésima marca real
current.end <- peaks2[k,3] #End de la iésima marca real
current.length <- current.end - current.start #Longitud de la iésima marca real
chr.length <- chromosomes.length[current.chr] #Length del actual cromosoma
#Ahora genero los mismos datos para regiones aleatorias
random.start <- floor(runif(n = 1,min = 1,max = chr.length))
random.end <- random.start + current.length
random.peaks2[k,1] <- current.chr
random.peaks2[k,2] <- random.start
random.peaks2[k,3] <- random.end
}
random.intersections[j] <- nrow(intersectBed(peaks.set1 = peaks1, peaks.set2 = random.peaks2 ))
}
p.value <- sum(random.intersections > nrow(real.intersection)) / number.randomisation
colnames(real.intersection) <- c("chromosome", "start", "end")
granges.intersection <- makeGRangesFromDataFrame(real.intersection,
keep.extra.columns=FALSE,
ignore.strand=FALSE,
seqinfo=NULL,
seqnames.field="chromosome",
start.field="start",
end.field="end",
starts.in.df.are.0based=FALSE)
peakAnno <- annotatePeak(granges.intersection, tssRegion=c(-2000, 2000),
TxDb=txdb, annoDb="org.At.tair.db")
annot.peaks <- as.data.frame(peakAnno)
target.genes <- subset(annot.peaks, distanceToTSS >= 2000 | distanceToTSS <= -2000)$geneId
target.genes <- paste(target.genes, collapse = ",")
bed.intersections[i,1] <- strsplit(x = as.character(combinations[i,1]), split = "_peaks")[[1]][1]
bed.intersections[i,2] <- strsplit(x = as.character(combinations[i,2]), split = "_peaks")[[1]][1]
bed.intersections[i,3] <- p.value
bed.intersections[i,5] <- nrow(real.intersection)
bed.intersections[i,6] <- target.genes
}
chromosomes.length <- read.table(file="../../../web_apps/peak_visualizer/data/bed_files/atha_chr_lengths.txt",as.is=T)[[1]]
number.randomisation <- 100
bed.files <- list.files(path = "../../../web_apps/peak_visualizer/data/bed_files/", pattern = "peaks.narrowPeak")
combinations <- expand.grid(bed.files, bed.files)
bed.intersections <- matrix(ncol = 6, nrow = nrow(combinations))
colnames(bed.intersections) <- c("TF1", "TF2", "p-value", "fdr", "number of intersections", "Genes" )
txdb <- TxDb.Athaliana.BioMart.plantsmart28
i <- 9
# Start the clock!
ptm <- proc.time()
for (i in 1:4)
# for (i in 1:nrow(combinations))
{
# print(paste0("test number ", i, " of ", nrow(combinations)))
print(paste0((i/nrow(combinations))*100, " %"))
peaks1 <- read.table(file = paste0("../../../web_apps/peak_visualizer/data/bed_files/", combinations[i,1]))
peaks2 <- read.table(file = paste0("../../../web_apps/peak_visualizer/data/bed_files/", combinations[i,2]))
real.intersection <- intersectBed(peaks.set1 = peaks1, peaks.set2 = peaks2)
random.intersections <- vector(mode = "numeric",length=number.randomisation) #Creating vector
for(j in 1:number.randomisation)
{
# print(j)
random.peaks2 <- matrix(nrow=nrow(peaks2),ncol=3) #Matriz con 3 columnas, una para el cromosoma, otra para el comienzo y otra para el final de la región aleatoria.
for(k in 1:nrow(peaks2))
{
current.chr <- peaks2[k,1][[1]] #Chr de la iésima marca real
current.start <- peaks2[k,2] #Start de la iésima marca real
current.end <- peaks2[k,3] #End de la iésima marca real
current.length <- current.end - current.start #Longitud de la iésima marca real
chr.length <- chromosomes.length[current.chr] #Length del actual cromosoma
#Ahora genero los mismos datos para regiones aleatorias
random.start <- floor(runif(n = 1,min = 1,max = chr.length))
random.end <- random.start + current.length
random.peaks2[k,1] <- current.chr
random.peaks2[k,2] <- random.start
random.peaks2[k,3] <- random.end
}
random.intersections[j] <- nrow(intersectBed(peaks.set1 = peaks1, peaks.set2 = random.peaks2 ))
}
p.value <- sum(random.intersections > nrow(real.intersection)) / number.randomisation
colnames(real.intersection) <- c("chromosome", "start", "end")
granges.intersection <- makeGRangesFromDataFrame(real.intersection,
keep.extra.columns=FALSE,
ignore.strand=FALSE,
seqinfo=NULL,
seqnames.field="chromosome",
start.field="start",
end.field="end",
starts.in.df.are.0based=FALSE)
peakAnno <- annotatePeak(granges.intersection, tssRegion=c(-2000, 2000),
TxDb=txdb, annoDb="org.At.tair.db")
annot.peaks <- as.data.frame(peakAnno)
target.genes <- subset(annot.peaks, distanceToTSS >= 2000 | distanceToTSS <= -2000)$geneId
target.genes <- paste(target.genes, collapse = ",")
bed.intersections[i,1] <- strsplit(x = as.character(combinations[i,1]), split = "_peaks")[[1]][1]
bed.intersections[i,2] <- strsplit(x = as.character(combinations[i,2]), split = "_peaks")[[1]][1]
bed.intersections[i,3] <- p.value
bed.intersections[i,5] <- nrow(real.intersection)
bed.intersections[i,6] <- target.genes
}
write.table(bed.intersections, file = "bed_intersections.txt", sep = "\t", row.names = FALSE)
# Stop the clock
proc.time() - ptm
3489.964 * 100
348996.4/60
5846/60
