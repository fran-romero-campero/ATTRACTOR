<<<<<<< HEAD
<<<<<<< Updated upstream
shiny::runApp('~/Dropbox/github_repos/ATTRACTOR/web_apps/attractor_dev')
install.packages("ggplot2")
=======
}
} else
{
day.length <- (24 - start.time) + end.time
factor.hora <- 180/(day.length)
max.time <- start.time + (day.length)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time || hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
}
plot(time.points,var.cosw)
day.length <- (24 - start.time) + end.time
day.length
factor.hora <- 180/(day.length)
max.time <- start.time + (day.length)/2
max.time
start.time <- 9
end.time <- 1
if(end.time > start.time)
{
factor.hora <- 180/(end.time - start.time)
max.time <- (start.time + end.time)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time && hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
} else
{
day.length <- (24 - start.time) + end.time
factor.hora <- 180/(day.length)
max.time <- start.time + (day.length)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else if(hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - 24 + hora)/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
}
plot(time.points,var.cosw)
start.time <- 9
end.time <- 1
if(end.time > start.time)
{
factor.hora <- 180/(end.time - start.time)
max.time <- (start.time + end.time)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time && hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
} else
{
day.length <- (24 - start.time) + end.time
factor.hora <- 180/(day.length)
max.time <- start.time + (day.length)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else if(hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - 24 - hora)/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
}
plot(time.points,var.cosw)
start.time <- 9
end.time <- 1
if(end.time > start.time)
{
factor.hora <- 180/(end.time - start.time)
max.time <- (start.time + end.time)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time && hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
} else
{
day.length <- (24 - start.time) + end.time
factor.hora <- 180/(day.length)
max.time <- start.time + (day.length)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else if(hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - (hora+24))/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
}
plot(time.points,var.cosw)
start.time <- 10
end.time <- 2
if(end.time > start.time)
{
factor.hora <- 180/(end.time - start.time)
max.time <- (start.time + end.time)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time && hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
} else
{
day.length <- (24 - start.time) + end.time
factor.hora <- 180/(day.length)
max.time <- start.time + (day.length)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else if(hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - (hora+24))/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
}
plot(time.points,var.cosw)
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/Pedro_de_los_Reyes/arabidopsis_thaliana_clock_network/web_apps/network_visualizer')
runApp('Dropbox/Pedro_de_los_Reyes/arabidopsis_thaliana_clock_network/web_apps/peak_visualizer')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("ChIPseeker", version = "3.8")
BiocManager::install("ChIPseeker", version = "3.8")
BiocManager::install("ChIPseeker", version = "3.8")
library("ChIPSeeker")
BiocManager::install("ChIPseeker", version = "3.8")
library("ChIPSeeker")
library("ChIPseeker")
options(repos = BiocInstaller::biocinstallRepos())
getOption("repos")
rsconnect::appDependencies()
options(rsconnect.max.bundle.size=3145728000)
rsconnect::appDependencies()
>>>>>>> c9c05f8dce0a97244d69a9e370809be8e2194677
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("BiocGenerics", version = "3.8")
options(repos = BiocInstaller::biocinstallRepos())
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("BiocInstaller", version = "3.8")
options(repos = BiocInstaller::biocinstallRepos())
getOption("repos")
shiny::runApp('Dropbox/ATTRACTOR/web_apps/attractor')
runApp('Dropbox/ATTRACTOR/web_apps/peak_visualizer')
runApp('Dropbox/ATTRACTOR/web_apps/attractor')
shiny::runApp('Dropbox/ATTRACTOR/web_apps/attractor')
shiny::runApp('Dropbox/github_repos/ATTRACTOR/web_apps/peak_visualizer')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor')
??????????????
?
""
??????????????""
?????????""
install.packages("PopGenome")
shiny::runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor')
shiny::runApp('Dropbox/github_repos/BRC1_transcriptional_network')
runApp('Dropbox/github_repos/BRC1_transcriptional_network')
options(repos = BiocInstaller::biocinstallRepos())
shiny::runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor')
shiny::runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor_dev')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor_dev')
data.frame(matrix(nrow=nrow(selected.genes.df), ncol=6))
output.selected.genes.df <- data.frame(matrix(nrow=nrow(selected.genes.df), ncol=6))
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor_dev')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor_dev')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor_dev')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor_dev')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor_dev')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor_dev')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor_dev')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor_dev')
library(SuperExactTest)
## Load network data
network.data <- read.table(file="../../../web_apps/attractor_dev/data/attractor_network_representation.tsv",header = TRUE,as.is=TRUE,sep="\t",quote = "")
setwd("~/Dropbox/github_repos/ATTRACTOR/network/analysis/intersections")
<<<<<<< HEAD
=======
<<<<<<< HEAD
tf1 <- read.table(file=paste0("../../../web_apps/peak_visualizer/data/targets_in_network/",tf.files[i]),
header = TRUE, as.is = TRUE)
tf2 <- read.table(file=paste0("../../../web_apps/peak_visualizer/data/targets_in_network/",tf.files[j]),
header = TRUE, as.is = TRUE)
set.of.genes <- read.table(file=paste0("../../../web_apps/peak_visualizer/data/clusters/by_peaks/",gene.files[k]),
header = FALSE, as.is = TRUE)
if(tf.files[i] != tf.files[j])
{
print("TEST")
result <- intersectSets(tf1,tf2,set.of.genes)
p.value <- result[1][[1]]
enrichment <- result[2][[1]]
intersect.genes <- result[3][[1]]
if (length(intersect.genes) !=0 & p.value < 0.000005)
{
print("HIT")
current.intersection[1] <- strsplit(tf.files[i], split = "_")[[1]][1]
current.intersection[2] <- strsplit(tf.files[j], split = "_")[[1]][1]
current.intersection[3] <- strsplit(gene.files[k], split = ".txt")[[1]][1]
current.intersection[4] <- p.value
current.intersection[5] <- enrichment
current.intersection[6] <- paste(intersect.genes, collapse= ",")
intersection.table <- rbind(intersection.table, current.intersection)
}
}
}
}
write.table(intersection.table, file="all_intersections.txt", sep="\t", row.names = FALSE)
}
### Intersection between nodes (genes) with high topological values, transcription factor target genes and ####
### genes peaking at each ZT.
topological.data <- read.table(file="../../attractor_network_topological_parameters.tsv",
sep = "\t", as.is = TRUE, row.names = NULL, header = TRUE)
head(topological.data)
gene.names <- topological.data$names
indegree.threshold <- quantile(topological.data$indegree, prob=0.95)
indegree.top <- gene.names[topological.data$indegree > indegree.threshold]
outdegree.threshold <- quantile(topological.data$outdegree, prob=0.95)
outdegree.top <- gene.names[topological.data$outdegree > outdegree.threshold]
topological.data$transitivity[is.na(topological.data$transitivity)] <- 0
trans.threshold <- quantile(topological.data$transitivity, prob=0.90)
trans.top <- gene.names[topological.data$trans > trans.threshold]
closeness.threshold <- quantile(topological.data$closeness, prob=0.95)
closeness.top <- gene.names[topological.data$closeness > closeness.threshold]
betweeness.threshold <- quantile(topological.data$betweeness, prob=0.95)
betweeness.top <- gene.names[topological.data$betweeness > betweeness.threshold]
eccentricity.threshold <- quantile(topological.data$eccentricity, prob=0.95)
eccentricity.top <- gene.names[topological.data$eccentricity > eccentricity.threshold]
#Loop to perform intersection between thisn set of genes, TF target genes and clusters.
top.genes <- list(indegree.top, outdegree.top, trans.top, closeness.top, betweeness.top, eccentricity.top)
names(top.genes) <- c("Indegree", "Outdegree", "Transitivity", "Closeness", "Betweeness", "Eccentricity")
#Initialize matrix to store the results
intersection.table <- matrix(ncol=6)
colnames(intersection.table) <- c("TF1", "Topological Top", "Cluster", "P value",
"Enrichment", "Intersection Genes")
#Initialize vector to add it as row into the matrix
current.intersection <- c()
head(intersection.table)
i <- 1
j <- 2
k <- 5
for (i in 1:length(tf.files))
{
for (j in 1: length(tf.files))
{
for (k in 1:length(gene.files))
{
tf1 <- read.table(file=paste0("../../../web_apps/peak_visualizer/data/targets_in_network/",tf.files[i]),
header = TRUE, as.is = TRUE)
top.genes <- top.genes[j]
set.of.genes <- read.table(file=paste0("../../../web_apps/peak_visualizer/data/clusters/by_peaks/",gene.files[k]),
header = FALSE, as.is = TRUE)
if(tf.files[i] != tf.files[j])
{
print("TEST")
result <- intersectSets(tf1,top.genes,set.of.genes, alias)
p.value <- result[1][[1]]
enrichment <- result[2][[1]]
intersect.genes <- result[3][[1]]
if (length(intersect.genes) !=0 & p.value < 0.000005)
{
print("HIT")
current.intersection[1] <- strsplit(tf.files[i], split = "_")[[1]][1]
current.intersection[2] <- names(top.genes[k])
current.intersection[3] <- strsplit(gene.files[k], split = ".txt")[[1]][1]
current.intersection[4] <- p.value
current.intersection[5] <- enrichment
current.intersection[6] <- paste(intersect.genes, collapse= ",")
intersection.table <- rbind(intersection.table, current.intersection)
}
}
}
}
write.table(intersection.table, file="all_intersections_with_topological_params.txt", sep="\t", row.names = FALSE)
}
######------Test of intersection between beds------#######
#Reading the bed files of the transcription factors
peaks1 <- read.table(file = "bed.files/PRR5_1_peaks.narrowPeak")
head(peaks1)
peaks2 <- read.table(file = "bed.files/PRR7_peaks.narrowPeak")
head(peaks2)
peaks3 <- read.table(file = "bed.files/PRR9_1_peaks.narrowPeak")
head(peaks3)
peaks.list <- list(peaks1, peaks2, peaks3)
length.sets <- sapply(X = peaks.list, FUN = nrow)
peaks.set1 <- peaks1
peaks.set2 <- peaks2
i <- 89
#Initialize matrix
intersection <- matrix(ncol = 3, nrow=0 )
current.intersection <- matrix(ncol = 3 )
for (i in 1:nrow(peaks.set1))
{
#Set the current peak values of set1
current.chr <- peaks.set1[i,1]
current.start <- peaks.set1[i,2]
current.end <- peaks.set1[i,3]
#Checking if there is intersection between the current peak and any peak of set2
option1 <- nrow(subset(peaks.set2, V1==current.chr & V2<=current.start & V3>=current.start))
option2 <- nrow(subset(peaks.set2, V1==current.chr & V2<=current.end & V3>=current.end))
print(i)
if(option1+option2 > 0)
{
print("HIT")
if(option1>0)
{
hit.peak2 <- subset(peaks.set2, V1==current.chr & V2<=current.start & V3>=current.start)
current.intersection[1,1] <- current.chr
current.intersection[1,2] <- current.start
current.intersection[1,3] <- hit.peak2$V3
}else
{
hit.peak2 <- subset(peaks.set2, V1==current.chr & V2<=current.end & V3>=current.end)
current.intersection[1,1] <- current.chr
current.intersection[1,2] <- hit.peak2$V2
current.intersection[1,3] <- current.end
}
intersection <- rbind(intersection, current.intersection)
}
}
top.genes[j]
top.genes
top.genes <- list(indegree.top, outdegree.top, trans.top, closeness.top, betweeness.top, eccentricity.top)
names(top.genes) <- c("Indegree", "Outdegree", "Transitivity", "Closeness", "Betweeness", "Eccentricity")
current.top <- top.genes[j]
current.top
current.top <- as.vector(top.genes[j])
current.top
result <- intersectSets(tf1,top.genes,set.of.genes,alias)
p.value <- result[1][[1]]
p.value
rm(result)
result <- intersectSets(tf1,top.genes,set.of.genes,alias)
p.value <- result[1][[1]]
result <- intersectSets(tf1,current.top,set.of.genes,alias)
p.value <- result[1][[1]]
p.value
result <- intersectSets(tf1,current.top,set.of.genes,alias)
p.value <- result[1][[1]]
enrichment <- result[2][[1]]
intersect.genes <- result[3][[1]]
enrichment
# R script for pre-processing
# Copyright (C) 2018  Francisco J. Romero-Campero, Pedro de los Reyes Rodríguez
# Ana Belén Romero Losada
# This program is free software: you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation, either version 3 of
# the License, or (at your option) any later version.
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# You should have received a copy of the GNU General Public
# License along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors: Pedro de los Reyes Rodríguez
#          Ana Belén Romero-Losada
#          Francisco J. Romero-Campero
#
# Contact: Francisco J. Romero-Campero - fran@us.es
# Date: September 2018
# Analysis of intersections among multiple sets is fundamental
# for in-depth understanding of their complex relationships
# This script performs intersections between the targets of two transcription factors and
# a set of genes.
#install.packages("SuperExactTest")
library(SuperExactTest)
>>>>>>> Stashed changes
##Reading the two sets TF target genes
tf1 <- read.table(file = "../../../web_apps/peak_visualizer/data/targets_in_network/CCA1_ZT02_targets_in_network.txt",
header = FALSE, as.is = TRUE)
tf2 <- read.table(file="../../../web_apps/peak_visualizer/data/targets_in_network/LHY_targets_in_network.txt",
header = FALSE, as.is = TRUE)
#Reading the group of genes peaking at specific time
genes.peak.zt <- read.table(file = "../../../network/clusters/peak_ZT0.txt",
header = FALSE, as.is = TRUE)
<<<<<<< Updated upstream
intersectSets(tf1, tf2, genes.peak.zt)
=======
## Load network data
network.data <- read.table(file="../../../web_apps/attractor_dev/data/attractor_network_representation.tsv",header = TRUE,as.is=TRUE,sep="\t",quote = "")
nrow(network.data)
## Function to extract the significance between three sets
>>>>>>> c9c05f8dce0a97244d69a9e370809be8e2194677
intersectSets <- function(tf1,tf2,set.of.genes){
=======
#EStablishing the sets to test
sets <- c(cca1.targets, lhy.targets, genes.peak.zt)
names(sets) <- c("cca1", "lhy", "peakZT0")
#Test and visualization of intersections
#vignette("set_html")
results <- supertest(x = sets, n = 6830)
help("plot.msets")
par(mar=c(3,3,3,3))
plot(results, sort.by = "size")
plot(results, Layout = "landscape")
results.table <- summary(results)
############# Exploring the output#####
typeof(results.table)
length(results.table)
names(results.table)
results.table$Barcode
results.table$otab
typeof(results.table$otab)
final.intersection <- results.table$otab[["111"]]
results.table$etab
results.table$P.value
tail(results.table$P.value, n=1)
enrichment <- (results.table$Table)[["FE"]][nrow(results.table$Table)]
intersection.genes <- (results.table$Table)[["Elements"]][nrow(results.table$Table)]
intersection.genes <- strsplit(intersection.genes, split = ", ")[[1]]
length(sets)
length.gene.sets <- sapply(X = sets,FUN = length)
#If you want to carry out the test introducing only numbers:
cpsets(x = 43 -1, L = length.gene.sets, n = 6830, lower.tail = FALSE)
###########################################################################################
##---------Function that returns p-value, enrichment and the---------------------------#
##---------set of genes in the intersecion (intersectSets)----------------------------------------#
##Correspondencia entre agi symbols y primary symbol
library(org.At.tair.db)
columns(org.At.tair.db)
my.key <- keys(org.At.tair.db, keytype="ENTREZID")
my.col <- c("SYMBOL", "TAIR")
alias2symbol.table <- select(org.At.tair.db, keys=my.key, columns=my.col, keytype="ENTREZID")
alias <- alias2symbol.table$SYMBOL
names(alias) <- alias2symbol.table$TAIR
alias[is.na(alias)] <- ""
intersectSets <- function(tf1,tf2,set.of.genes, alias){
=======
}
} else
{
day.length <- (24 - start.time) + end.time
factor.hora <- 180/(day.length)
max.time <- start.time + (day.length)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time || hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
}
plot(time.points,var.cosw)
day.length <- (24 - start.time) + end.time
day.length
factor.hora <- 180/(day.length)
max.time <- start.time + (day.length)/2
max.time
start.time <- 9
end.time <- 1
if(end.time > start.time)
{
factor.hora <- 180/(end.time - start.time)
max.time <- (start.time + end.time)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time && hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
} else
{
day.length <- (24 - start.time) + end.time
factor.hora <- 180/(day.length)
max.time <- start.time + (day.length)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else if(hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - 24 + hora)/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
}
plot(time.points,var.cosw)
start.time <- 9
end.time <- 1
if(end.time > start.time)
{
factor.hora <- 180/(end.time - start.time)
max.time <- (start.time + end.time)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time && hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
} else
{
day.length <- (24 - start.time) + end.time
factor.hora <- 180/(day.length)
max.time <- start.time + (day.length)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else if(hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - 24 - hora)/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
}
plot(time.points,var.cosw)
start.time <- 9
end.time <- 1
if(end.time > start.time)
{
factor.hora <- 180/(end.time - start.time)
max.time <- (start.time + end.time)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time && hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
} else
{
day.length <- (24 - start.time) + end.time
factor.hora <- 180/(day.length)
max.time <- start.time + (day.length)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else if(hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - (hora+24))/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
}
plot(time.points,var.cosw)
start.time <- 10
end.time <- 2
if(end.time > start.time)
{
factor.hora <- 180/(end.time - start.time)
max.time <- (start.time + end.time)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time && hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
} else
{
day.length <- (24 - start.time) + end.time
factor.hora <- 180/(day.length)
max.time <- start.time + (day.length)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else if(hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - (hora+24))/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
}
plot(time.points,var.cosw)
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/Pedro_de_los_Reyes/arabidopsis_thaliana_clock_network/web_apps/network_visualizer')
runApp('Dropbox/Pedro_de_los_Reyes/arabidopsis_thaliana_clock_network/web_apps/peak_visualizer')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("ChIPseeker", version = "3.8")
BiocManager::install("ChIPseeker", version = "3.8")
BiocManager::install("ChIPseeker", version = "3.8")
library("ChIPSeeker")
BiocManager::install("ChIPseeker", version = "3.8")
library("ChIPSeeker")
library("ChIPseeker")
options(repos = BiocInstaller::biocinstallRepos())
getOption("repos")
rsconnect::appDependencies()
options(rsconnect.max.bundle.size=3145728000)
rsconnect::appDependencies()
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("BiocGenerics", version = "3.8")
options(repos = BiocInstaller::biocinstallRepos())
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("BiocInstaller", version = "3.8")
options(repos = BiocInstaller::biocinstallRepos())
getOption("repos")
shiny::runApp('Dropbox/ATTRACTOR/web_apps/attractor')
runApp('Dropbox/ATTRACTOR/web_apps/peak_visualizer')
runApp('Dropbox/ATTRACTOR/web_apps/attractor')
shiny::runApp('Dropbox/ATTRACTOR/web_apps/attractor')
shiny::runApp('Dropbox/github_repos/ATTRACTOR/web_apps/peak_visualizer')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor')
??????????????
?
""
??????????????""
?????????""
install.packages("PopGenome")
shiny::runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor')
shiny::runApp('Dropbox/github_repos/BRC1_transcriptional_network')
runApp('Dropbox/github_repos/BRC1_transcriptional_network')
options(repos = BiocInstaller::biocinstallRepos())
shiny::runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor')
shiny::runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor_dev')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor_dev')
data.frame(matrix(nrow=nrow(selected.genes.df), ncol=6))
output.selected.genes.df <- data.frame(matrix(nrow=nrow(selected.genes.df), ncol=6))
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor_dev')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor_dev')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor_dev')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor_dev')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor_dev')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor_dev')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor_dev')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor_dev')
library(SuperExactTest)
## Load network data
network.data <- read.table(file="../../../web_apps/attractor_dev/data/attractor_network_representation.tsv",header = TRUE,as.is=TRUE,sep="\t",quote = "")
setwd("~/Dropbox/github_repos/ATTRACTOR/network/analysis/intersections")
## Load network data
network.data <- read.table(file="../../../web_apps/attractor_dev/data/attractor_network_representation.tsv",header = TRUE,as.is=TRUE,sep="\t",quote = "")
nrow(network.data)
## Function to extract the significance between three sets
intersectSets <- function(tf1,tf2,set.of.genes){
>>>>>>> 7ba0e6259f3c8b997e548c41db0010c13627da42
>>>>>>> Stashed changes
intersection.data <- list()
sets <- list(tf1, tf2, set.of.genes)
#names(sets) <- c("cca1", "lhy", "peakZT0")
results <- supertest(x = sets, n = 5778)
results.table <- summary(results)
p.value <- tail(results.table$P.value, n=1) #Get the last p-value
enrichment <- (results.table$Table)[["FE"]][nrow(results.table$Table)]
intersection.genes <- (results.table$Table)[["Elements"]][nrow(results.table$Table)]
intersection.genes <- strsplit(intersection.genes, split = ", ")[[1]]
<<<<<<< HEAD
<<<<<<< Updated upstream
=======
<<<<<<< HEAD
intersection.genes.agi <- intersection.genes
intersection.genes.primary.symbol <- alias[intersection.genes]
names(intersection.genes.primary.symbol) <- NULL
gene.table <- matrix(nrow=length(intersection.genes), ncol=3)
colnames(gene.table) <- c("AGI", "Primary Symbol", "Description")
gene.table[,1] <- intersection.genes.agi
gene.table[,2] <- intersection.genes.primary.symbol
#  gene.table[,3] <- description
>>>>>>> Stashed changes
=======
intersection.data <- list()
>>>>>>> c9c05f8dce0a97244d69a9e370809be8e2194677
intersection.data[[1]] <- p.value
intersection.data[[2]] <- enrichment
intersection.data[[3]] <- intersection.genes
names(intersection.data) <- c("p-value", "enrichment", "genes")
return(intersection.data)
}
<<<<<<< HEAD
intersectSets(tf1, tf2, genes.peak.zt)
intersect.genes <- result[3][[1]]
result <- intersectSets(tf1, tf2, genes.peak.zt)
intersect.genes <- result[3][[1]]
intersect.genes
# columns(org.At.tair.db)
my.key <- keys(org.At.tair.db, keytype="ENTREZID")
my.col <- c("SYMBOL", "TAIR")
my.key
my.col <- c("SYMBOL", "TAIR")
runApp('~/Dropbox/github_repos/ATTRACTOR/web_apps/network_visualizer')
my.col
intersectSets(tf1, tf2, genes.peak.zt)
result <- intersectSets(tf1, tf2, genes.peak.zt)
intersect.genes <- result[3][[1]]
intersect.genes <- result[3][[1]]
intersect.genes
columns(org.At.tair.db)
my.key <- keys(org.At.tair.db, keytype="ENTREZID")
head(my.key)
my.key <- keys(org.At.tair.db, keytype="ENTREZID")
my.col <- c("SYMBOL", "TAIR")
my.col
?select
columns(org.At.tair.db)
my.key <- keys(org.At.tair.db, keytype="ENTREZID")
my.col <- c("SYMBOL", "TAIR")
alias2symbol.table <- select(org.At.tair.db, keys=my.key, columns=my.col, keytype="ENTREZID")
alias2symbol.table
alias <- alias2symbol.table$SYMBOL
names(alias) <- alias2symbol.table$TAIR
#target.alias <- alias[target.genes]
alias[is.na(alias)] <- ""
alias
agis <-alias2symbol.table$TAIR
names(agis) <- alias2symbol.table$SYMBOL
agis
agis[is.na(agis)] <- ""
agis(intersect.genes)
agis[intersect.genes]
intersect.genes
alias <- alias2symbol.table$SYMBOL
names(alias) <- alias2symbol.table$TAIR
alias[intersect.genes]
alias <- alias2symbol.table$SYMBOL
names(alias) <- alias2symbol.table$TAIR
alias[is.na(alias)] <- ""
alias[intersect.genes]
table.of.genes <- matrix(ncol=5, nrow = length(intersection.genes))
table.of.genes <- matrix(ncol=5, nrow = length(intersecti.genes))
table.of.genes <- matrix(ncol=5, nrow = length(intersect.genes))
table.of.genes
colnames(table.of.genes) <- c("Primary_Symbol", "AGI", "Description", "Peak", "Trough")
colnames(table.of.genes) <- c("Primary_Symbol", "AGI", "Description", "Peak", "Trough")
table.of.genes
table.of.genes[,"AGI"] <- intersect.genes
table.of.genes
table.of.genes[,"Primary_Symbol"] <- alias[intersect.genes]
table.of.genes
#Read expression data table
expression.data <- read.table(file="data/athaliana_neutral_circadian_genes.txt",
as.is = TRUE, header = TRUE, row.names = NULL)
#Read expression data table
expression.data <- read.table(file="../../../web_apps/network_visualizer/data/athaliana_neutral_circadian_genes.txt",
as.is = TRUE, header = TRUE, row.names = NULL)
head(expression.data)
expression.data[alias[intersect.genes],]
alias[intersect.genes]
alias[intersect.genes]
names(alias[intersect.genes])
expression.data[intersect.genes,]
expression.data[1,3]
head(expression.data)
subset(expression.data, genes == intersect.genes)
#Read expression data table
expression.data <- read.table(file="../../../web_apps/network_visualizer/data/athaliana_neutral_circadian_genes.txt",
as.is = TRUE, header = TRUE, row.names = NULL)
head(expression.data)
intersect.genes
<<<<<<< Updated upstream
subset(expression.data, genes == intersect.genes)
subset(expression.data, expression.data$genes == intersect.genes)
subset(expression.data, expression.data$genes == intersect.genes)
subset(expression.data, genes == intersect.genes)
intersect.genes
#Read expression data table
expression.data <- read.table(file="../../../web_apps/network_visualizer/data/athaliana_neutral_circadian_genes.txt",
as.is = TRUE, header = TRUE, row.names = NULL)
head(expression.data)
subset(expression.data, genes == intersect.genes)
length(intersect.genes)
head(expression.data)
subset(expression.data, genes == "ATMG00750")
subset(expression.data, genes == as.character(intersection.genes))
subset(expression.data, genes == as.character(intersect.genes))
subset(expression.data, genes == as.vector(intersect.genes))
expression.data$genes == intersect.genes
expression.data$peaks[expression.data$genes == intersect.genes]
length(expression.data$genes)
length(expression.data$peaks)
intersect.genes
class(intersect.genes)
as.vector(intersect.genes)
class(as.vector(intersect.genes))
class(as.list(intersect.genes))
subset(expression.data, genes == as.list(intersect.genes))
test <- c("AT1G13260", "AT2G18300")
class(test)
test
intersect.genes
intersect.genes[1]
subset(expression.data, genes == "AT1G01620")
result
result[3]
result[3][[1]]
intersect.genes
test
subset(expression.data, genes == intersect.genes)
=======
print("HIT")
current.intersection[1] <- strsplit(tf.files[i], split = "_")[[1]][1]
current.intersection[1]
current.intersection[2]
current.intersection[2] <- names(top.genes[j])
current.intersection[2]
for (i in 1:length(tf.files))
{
for (j in 1: length(top.genes))
{
for (k in 1:length(gene.files))
{
tf1 <- read.table(file=paste0("../../../web_apps/peak_visualizer/data/targets_in_network/",tf.files[i]),
header = TRUE, as.is = TRUE)
current.top <- as.vector(top.genes[j])
set.of.genes <- read.table(file=paste0("../../../web_apps/peak_visualizer/data/clusters/by_peaks/",gene.files[k]),
header = FALSE, as.is = TRUE)
if(tf.files[i] != tf.files[j])
{
print("TEST")
result <- intersectSets(tf1,current.top,set.of.genes,alias)
p.value <- result[1][[1]]
enrichment <- result[2][[1]]
intersect.genes <- result[3][[1]]
if (length(intersect.genes) !=0 & p.value < 0.000005)
{
print("HIT")
current.intersection[1] <- strsplit(tf.files[i], split = "_")[[1]][1]
current.intersection[2] <- names(top.genes[j])
current.intersection[3] <- strsplit(gene.files[k], split = ".txt")[[1]][1]
current.intersection[4] <- p.value
current.intersection[5] <- enrichment
current.intersection[6] <- paste(intersect.genes, collapse= ",")
intersection.table <- rbind(intersection.table, current.intersection)
}
}
}
}
write.table(intersection.table, file="all_intersections_with_topological_params.txt", sep="\t", row.names = FALSE)
}
=======
intersection.data <- list()
intersection.data[[1]] <- p.value
intersection.data[[2]] <- enrichment
intersection.data[[3]] <- intersection.genes
names(intersection.data) <- c("p-value", "enrichment", "genes")
return(intersection.data)
}
=======
>>>>>>> c9c05f8dce0a97244d69a9e370809be8e2194677
## Loop over TFs and circadian genes
tf.names <- colnames(network.data)[6:21]
number.of.test <- 6*5*(length(tf.names) -1)*length(tf.names)/2
tfs.1 <- vector(mode="character",length=number.of.test)
tfs.2 <- vector(mode="character",length=number.of.test)
peaks <- vector(mode="character",length=number.of.test)
troughs <- vector(mode="character",length=number.of.test)
pvalues <- vector(mode="numeric",length=number.of.test)
enrichments <- vector(mode="numeric",length=number.of.test)
genes.in.intersection <- vector(mode="character",length=number.of.test)
n <- 1
for(i in 1:(length(tf.names)-1))
{
for(j in (i+1):length(tf.names))
{
for(k in seq(from=0,to=20,by=4))
{
for(l in seq(from=0,to=20,by=4))
{
tf.i <- tf.names[i]
tf.j <- tf.names[j]
if(k != l)
{
targets.tf.i <- network.data$names[network.data[,tf.i] == 1]
targets.tf.j <- network.data$names[network.data[,tf.j] == 1]
circadian.gene.set <- subset(network.data, peak.zt == paste0("peak",k) & trough.zt == paste0("trough",l))$names
intersection.result <- intersectSets(tf1 = targets.tf.i, tf2 = targets.tf.j, set.of.genes = circadian.gene.set)
tfs.1[n] <- tf.i
tfs.2[n] <- tf.j
peaks[n] <- paste0("ZT",k)
troughs[n] <- paste0("ZT",l)
pvalues[n] <- intersection.result$`p-value`
enrichments[n] <- intersection.result$enrichment
genes.in.intersection[n]  <- paste(intersection.result$genes,collapse = ",")
n <- n + 1
}
}
}
}
}
fdr.values <- p.adjust(p = pvalues,method = "BH")
significance.intersection <- data.frame(tf1 = tfs.1,
tf2 = tfs.2,
peak.zt = peaks,
trough.zt = troughs,
pvalues = pvalues,
fdr = fdr.values,
enrichment = enrichments,
genes = genes.in.intersection)
head(significance.intersection)
write.table(x = significance.intersection,file = "significance_intersection.tsv",quote = F,sep = "\t",row.names = F)
significance.results <- read.table(file="significance_intersection.tsv",header = T,sep = "\t")
significance.results <- read.table(file="significance_intersection.tsv",header = T,sep = "\t",as.is=T)
sum(significance.results$fdr < 0.001 & significance.results$enrichment > 5)
sum(significance.results$fdr < 0.001 & significance.results$enrichment > 10)
sum(significance.results$fdr < 0.01 & significance.results$enrichment > 2)
subset(significance.results, fdr < 0.01 & enrichment > 2)
filtered.significant.results.1 <- subset(significance.results, fdr < 0.01 & enrichment > 2)
write.table(x = filtered.significant.results.1,file = "filtered_significant_results_1.tsv",quote = F,sep = "\t",row.names = F)
filtered.significant.results.2 <- subset(significance.results, fdr < 0.001 & enrichment > 10)
write.table(x = filtered.significant.results.2,file = "filtered_significant_results_2.tsv",quote = F,sep = "\t",row.names = F)
## Load library and graph
library(igraph)
## Load ATTRACTOR network and extract gene names
atha.graph <- read.graph(file="../attractor.graphml", format = "graphml")
## Load ATTRACTOR network and extract gene names
atha.graph <- read.graph(file="../../attractor.graphml", format = "graphml")
vertex.names <- V(atha.graph)$name
length(vertex.names)
## Scale free property
degree(graph = atha.graph,mode = "in")
hist(in.degree)
## Scale free property
in.degree <- degree(graph = atha.graph,mode = "in")
hist(in.degree)
in.degree
table(in.degree)
in.degree.distribution <- table(in.degree)
names(in.degree.distribution)
as.numeric(names(in.degree.distribution))
x.coord <- log10(in.degree.distribution)
y.coord <- log10(as.numeric(names(in.degree.distribution)))
x.coord <- log10(in.degree.distribution)
x.coord <- log10(as.numeric(names(in.degree.distribution)))
y.coord <- log10(in.degree.distribution)
plot(x.coord,y.coord)
lm.r <- lm(y.coord ~ x.coord)
summary(lm.r)
x.coord.1 <- seq(from=0,to=2,by=0.01)
x.coord.1 <- seq(from=0,to=2,by=0.01)
y.coord.1 <- beta + alpha*x.coord.1
plot(x.coord,y.coord)
lines(x.coord.1,y.coord.1)
x.coord.1 <- seq(from=0,to=2,by=0.01)
y.coord.1 <- beta + alpha*x.coord.1
plot(x.coord,y.coord)
lines(x.coord.1,y.coord.1)
beta <- 4.0432
alpha <- -2.8508
x.coord.1 <- seq(from=0,to=2,by=0.01)
y.coord.1 <- beta + alpha*x.coord.1
plot(x.coord,y.coord)
lines(x.coord.1,y.coord.1)
hist(in.degree)
y.coord.2 <- beta*x.coord^alpha
lines(x.coord,y.coord.2)
y.coord.2
x.coord
<<<<<<< HEAD
>>>>>>> 7ba0e6259f3c8b997e548c41db0010c13627da42
>>>>>>> Stashed changes
=======
>>>>>>> c9c05f8dce0a97244d69a9e370809be8e2194677
