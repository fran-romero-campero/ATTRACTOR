cds.data.target.gene <- subset(cds.data, seqnames == target.gene.chr & (start >= target.gene.start & end <= target.gene.end))
## Transform cds coordinates to current range
if(target.gene.strand == "+")
{
cds.data.target.gene$start <- cds.data.target.gene$start - min.pos + input$promoter.length
cds.data.target.gene$end <- cds.data.target.gene$end - min.pos + input$promoter.length
} else if (target.gene.strand == "-")
{
cds.data.target.gene$start <- cds.data.target.gene$start - min.pos + input$fiveprime.length
cds.data.target.gene$end <- cds.data.target.gene$end - min.pos + input$fiveprime.length
}
cds.width <- 3
for(i in 1:nrow(cds.data.target.gene))
{
# Determine current cds start/end
current.cds.start <- cds.data.target.gene$start[i]
current.cds.end <- cds.data.target.gene$end[i]
# Determine curret cds coordinates for the polygon and represent it
cds.x <- c(current.cds.start,current.cds.end,current.cds.end,current.cds.start)
cds.y <- c(gene.height + cds.width, gene.height + cds.width, gene.height - cds.width, gene.height - cds.width)
polygon(x = cds.x, y = cds.y, col = "blue",border = "blue")
}
## Draw arrow to represent transcription direction
if(target.gene.strand == "+")
{
lines(c(input$promoter.length,input$promoter.length,input$promoter.length+100),y=c(gene.height,gene.height+5,gene.height+5),lwd=3)
lines(c(input$promoter.length+50,input$promoter.length+100),y=c(gene.height+6,gene.height+5),lwd=3)
lines(c(input$promoter.length+50,input$promoter.length+100),y=c(gene.height+4,gene.height+5),lwd=3)
} else if (target.gene.strand == "-")
{
lines(c(current.length - input$promoter.length, current.length - input$promoter.length, current.length - input$promoter.length-100),y=c(gene.height,gene.height+5,gene.height+5),lwd=3)
lines(c(current.length - input$promoter.length-50, current.length - input$promoter.length - 100),y=c(gene.height + 6, gene.height + 5),lwd=3)
lines(c(current.length - input$promoter.length-50, current.length - input$promoter.length - 100),y=c(gene.height + 4, gene.height + 5),lwd=3)
}
## Draw promoter range
if(target.gene.strand == "+")
{
axis(side = 1,labels = c(- input$promoter.length, - input$promoter.length / 2,"TSS"),at = c(1,input$promoter.length/2,input$promoter.length),lwd=2,cex=1.5,las=2,cex=2)
} else if(target.gene.strand == "-")
{
axis(side = 1,labels = c("TSS",- input$promoter.length / 2,- input$promoter.length),at = c(current.length-input$promoter.length,current.length-input$promoter.length/2, current.length),lwd=2,cex=1.5,las=2,cex=2)
}
selected.bigwig.files <- bigwig.files[input$names.tfs]
selected.bed.files <- bed.files[input$names.tfs]
## Since ChIPpeakAnno needs more than one region to plot our region
## is duplicated
regions.plot <- GRanges(rbind(range.to.plot,range.to.plot))
## Import signal from the bigwig files
cvglists <- sapply(selected.bigwig.files, import,
format="BigWig",
which=regions.plot,
as="RleList")
names(cvglists) <- input$names.tfs
## Compute signal in the region to plot
chip.signal <- featureAlignedSignal(cvglists, regions.plot,
upstream=ceiling(current.length/2),
downstream=ceiling(current.length/2),
n.tile=current.length)
## Compute mean signal
chip.signal.means <- matrix(nrow=number.tfs, ncol=ncol(chip.signal[[1]]))
for(i in 1:number.tfs)
{
if(target.gene.strand == "+")
{
chip.signal.means[i, ] <- colMeans(chip.signal[[i]],na.rm = TRUE)
} else if (target.gene.strand == "-")
{
chip.signal.means[i, ] <- rev(colMeans(chip.signal[[i]],na.rm = TRUE))
}
}
selected.motifs.pwm <- motifs.pwm
selected.motif.names <- names(selected.motifs.pwm)
selected.motif.ids <- motif.ids[selected.motif.names]
## Initialize data frame containing TF binding sequences in the peak regions
df.hits <- data.frame(0,0,"","","")
colnames(df.hits) <- c("tf_number","position","id","name","seq")
## Width of the rectangule representing the peak reagion
peak.width <- 1
for(i in 1:number.tfs)
{
## Extract bed file name 1 and read it
current.bed.file <- selected.bed.files[i]
current.peaks <- read.table(file=current.bed.file,header = F, as.is = T)
peak.coordinates <- subset(current.peaks, V1 == range.to.plot$seqnames & V2 >= range.to.plot$start & V3 <= range.to.plot$end)
current.peaks.to.plot <- peak.coordinates[,2:3]
## Transform coordinates
current.peaks.to.plot <- current.peaks.to.plot - range.to.plot$start
## Check if there are peaks for the target gene
if(nrow(current.peaks.to.plot) > 0)
{
## Normalization
chip.signal.means[i, ] <- 10 * chip.signal.means[i, ] / max(chip.signal.means[i, ])
#motifs.in.peaks <- vector(mode="list", length=nrow(current.peaks.to.plot))
for(j in 1:nrow(current.peaks.to.plot))
{
## Extract start and end point of each peak region
current.peak.start <- current.peaks.to.plot[j,1]
current.peak.end <- current.peaks.to.plot[j,2]
## Computer coordinates for polygon and draw it
peak.x <- c(current.peak.start,current.peak.end,
current.peak.end,current.peak.start)
peak.y <- c(25*(i - 1) - 5 + peak.width, 25*(i - 1) - 5 + peak.width,
25*(i - 1) - 5 - peak.width, 25*(i - 1) - 5 - peak.width)
polygon(x = peak.x, y = peak.y, col = area.colors[i], border = line.colors[i],lwd=2)
## Identify TF binding DNA motifs
peak.chr <- peak.coordinates[j, 1]
peak.start <- peak.coordinates[j, 2]
peak.end <- peak.coordinates[j, 3]
## Extract peak sequence
if(peak.chr == "1")
{
peak.sequence <- c2s(chr1[peak.start:peak.end])
} else if(peak.chr == "2")
{
peak.sequence <- c2s(chr2[peak.start:peak.end])
} else if(peak.chr == "3")
{
peak.sequence <- c2s(chr3[peak.start:peak.end])
} else if(peak.chr == "4")
{
peak.sequence <- c2s(chr4[peak.start:peak.end])
} else if(peak.chr == "5")
{
peak.sequence <- c2s(chr5[peak.start:peak.end])
}
peak.rev.comp.sequence <- reverse.complement(peak.sequence)
for(k in 1:length(selected.motifs.pwm))
{
motif.pwm <- selected.motifs.pwm[[k]]
hits.fw <- matchPWM(motif.pwm, peak.sequence,
min.score = paste0(input$min.score.pwm,"%"))
hits.fw.seqs <- as.data.frame(hits.fw)[[1]]
hits.fw <- as(hits.fw, "IRanges")
hits.fw.start <- start(hits.fw)
hits.fw.end <- end(hits.fw)
if(length(hits.fw.start) > 0)
{
df.hits.fw <- data.frame(rep(i,length(hits.fw.start)),
((hits.fw.start+hits.fw.end)/2) + current.peak.start,
rep(selected.motif.ids[k],length(hits.fw.start)),
rep(selected.motif.names[k],length(hits.fw.start)),
hits.fw.seqs)
colnames(df.hits.fw)  <- c("tf_number","position","id","name","seq")
df.hits <- rbind(df.hits,df.hits.fw)
}
hits.rev <- matchPWM(motif.pwm, peak.rev.comp.sequence,
min.score = paste0(input$min.score.pwm,"%"))
hits.rev.seqs <- as.data.frame(hits.rev)[[1]]
hits.rev.seqs <- sapply(hits.rev.seqs,reverse.complement)
names(hits.rev.seqs) <- NULL
hits.rev <- as(hits.rev, "IRanges")
hits.rev.start <- nchar(peak.sequence) - end(hits.rev) + 1
hits.rev.end <- nchar(peak.sequence) - start(hits.rev) + 1
if(length(hits.rev.start) > 0)
{
df.hits.rev <- data.frame(rep(i,length(hits.rev.start)),
((hits.rev.start+hits.rev.end)/2) + current.peak.start,
rep(selected.motif.ids[k],length(hits.rev.start)),
rep(selected.motif.names[k],length(hits.rev.start)),
hits.rev.seqs)
colnames(df.hits.rev)  <- c("tf_number","position","id","name","seq")
df.hits <- rbind(df.hits,df.hits.rev)
}
}
}
}
}
## Remove first line of the data frame added just for technical reason
df.hits <- df.hits[-1,]
## Draw TF binding sites
detected.tfbs <- unique(as.vector(df.hits$name))
number.of.shapes <- ceiling(length(detected.tfbs) / length(symbol.color))
necessary.shapes <- rep(symbol.shapes[1:number.of.shapes],each = length(detected.tfbs)/number.of.shapes)
necessary.colors <- rep(symbol.color,number.of.shapes)
if(length(detected.tfbs) > 0)
{
for(i in 1:length(detected.tfbs))
{
current.tfbs <- detected.tfbs[i]
current.shape <- necessary.shapes[i]
current.color <- necessary.colors[i]
positions <- subset(df.hits, name == current.tfbs)
for(j in 1:nrow(positions))
{
tf.to.draw <- positions$tf_number[j]
pos.to.draw <- positions$position[j]
points(x = pos.to.draw, y = 25*(tf.to.draw - 1) - 5 - 5*peak.width,
pch = current.shape, col = current.color, cex = 1)
}
}
## Add legend for TFBS
legend.step <- 10
for(i in 1:length(detected.tfbs))
{
points(x = -3000, y = upper.lim - (i-1)*legend.step,
pch=necessary.shapes[i], col = necessary.colors[i],cex = 1)
current.seq <- as.character(subset(df.hits,name == detected.tfbs[i])[["seq"]][[1]])
current.label <- paste(c(detected.tfbs[i], "  -  ", current.seq ),collapse="")
text(x = -2900, y = upper.lim - (i-1)*legend.step, labels = current.label,
adj = 0,cex = 0.7)
}
}
## Draw profiles for TF binding
for(i in 1:number.tfs)
{
## Compute base line for current TF
current.base.line <- 25 * (i - 1)
## Represent signal from the current TF
lines(chip.signal.means[i,]+current.base.line,type="l",col=line.colors[i],lwd=3)
## Determine polygon coordinates and represent it
cord.y <- c(current.base.line,chip.signal.means[i,]+current.base.line,current.base.line)
cord.x <- 1:length(cord.y)
polygon(cord.x,cord.y,col=area.colors[i])
text(x = -50,y = 25*(i-1) + 12,labels = input$names.tfs[i],adj = 1,col = line.colors[i],font = 2)
}
output$plot.to.chulo.to.wapo <- renderPlot({
## Sanity checks
validate(
need(length(input$names.tfs) > 0 , "Please select a set of transcription factors")
)
validate(
need((length(input$selected.motifs) > 0 || input$all.motifs), "Please select a set of DNA motifs")
)
plot(cord.x, rep(gene.height,length(cord.x)),type="l",col="black",lwd=3,ylab="",
cex.lab=2,axes=FALSE,xlab="",main="",cex.main=2,
ylim=c(-30,upper.lim),xlim=c(-3000,max(cord.x)))
## Extract exons for target gene
exons.data.target.gene <- subset(exons.data, seqnames == target.gene.chr & (start >= target.gene.start & end <= target.gene.end))
## Transform exon coordinates to current range
min.pos <- min(exons.data.target.gene$start)
if(target.gene.strand == "+")
{
exons.data.target.gene$start <- exons.data.target.gene$start - min.pos + input$promoter.length
exons.data.target.gene$end <- exons.data.target.gene$end - min.pos + input$promoter.length
} else if(target.gene.strand == "-")
{
exons.data.target.gene$start <- exons.data.target.gene$start - min.pos + input$fiveprime.length
exons.data.target.gene$end <- exons.data.target.gene$end - min.pos + input$fiveprime.length
}
## Represent exons
exon.width <- 2
for(i in 1:nrow(exons.data.target.gene))
{
# Determine start/end for each exon
current.exon.start <- exons.data.target.gene$start[i]
current.exon.end <- exons.data.target.gene$end[i]
## Determine coordinates for each exon polygon and represent it
exon.x <- c(current.exon.start,current.exon.end,current.exon.end,current.exon.start)
exon.y <- c(gene.height + exon.width, gene.height + exon.width, gene.height - exon.width, gene.height - exon.width)
polygon(x = exon.x, y = exon.y, col = "blue",border = "blue")
}
## Extract cds for target gene
cds.data.target.gene <- subset(cds.data, seqnames == target.gene.chr & (start >= target.gene.start & end <= target.gene.end))
## Transform cds coordinates to current range
if(target.gene.strand == "+")
{
cds.data.target.gene$start <- cds.data.target.gene$start - min.pos + input$promoter.length
cds.data.target.gene$end <- cds.data.target.gene$end - min.pos + input$promoter.length
} else if (target.gene.strand == "-")
{
cds.data.target.gene$start <- cds.data.target.gene$start - min.pos + input$fiveprime.length
cds.data.target.gene$end <- cds.data.target.gene$end - min.pos + input$fiveprime.length
}
cds.width <- 3
for(i in 1:nrow(cds.data.target.gene))
{
# Determine current cds start/end
current.cds.start <- cds.data.target.gene$start[i]
current.cds.end <- cds.data.target.gene$end[i]
# Determine curret cds coordinates for the polygon and represent it
cds.x <- c(current.cds.start,current.cds.end,current.cds.end,current.cds.start)
cds.y <- c(gene.height + cds.width, gene.height + cds.width, gene.height - cds.width, gene.height - cds.width)
polygon(x = cds.x, y = cds.y, col = "blue",border = "blue")
}
## Draw arrow to represent transcription direction
if(target.gene.strand == "+")
{
lines(c(input$promoter.length,input$promoter.length,input$promoter.length+100),y=c(gene.height,gene.height+5,gene.height+5),lwd=3)
lines(c(input$promoter.length+50,input$promoter.length+100),y=c(gene.height+6,gene.height+5),lwd=3)
lines(c(input$promoter.length+50,input$promoter.length+100),y=c(gene.height+4,gene.height+5),lwd=3)
} else if (target.gene.strand == "-")
{
lines(c(current.length - input$promoter.length, current.length - input$promoter.length, current.length - input$promoter.length-100),y=c(gene.height,gene.height+5,gene.height+5),lwd=3)
lines(c(current.length - input$promoter.length-50, current.length - input$promoter.length - 100),y=c(gene.height + 6, gene.height + 5),lwd=3)
lines(c(current.length - input$promoter.length-50, current.length - input$promoter.length - 100),y=c(gene.height + 4, gene.height + 5),lwd=3)
}
## Draw promoter range
if(target.gene.strand == "+")
{
axis(side = 1,labels = c(- input$promoter.length, - input$promoter.length / 2,"TSS"),at = c(1,input$promoter.length/2,input$promoter.length),lwd=2,cex=1.5,las=2,cex=2)
} else if(target.gene.strand == "-")
{
axis(side = 1,labels = c("TSS",- input$promoter.length / 2,- input$promoter.length),at = c(current.length-input$promoter.length,current.length-input$promoter.length/2, current.length),lwd=2,cex=1.5,las=2,cex=2)
}
selected.bigwig.files <- bigwig.files[input$names.tfs]
selected.bed.files <- bed.files[input$names.tfs]
## Since ChIPpeakAnno needs more than one region to plot our region
## is duplicated
regions.plot <- GRanges(rbind(range.to.plot,range.to.plot))
## Import signal from the bigwig files
cvglists <- sapply(selected.bigwig.files, import,
format="BigWig",
which=regions.plot,
as="RleList")
names(cvglists) <- input$names.tfs
## Compute signal in the region to plot
chip.signal <- featureAlignedSignal(cvglists, regions.plot,
upstream=ceiling(current.length/2),
downstream=ceiling(current.length/2),
n.tile=current.length)
## Compute mean signal
chip.signal.means <- matrix(nrow=number.tfs, ncol=ncol(chip.signal[[1]]))
for(i in 1:number.tfs)
{
if(target.gene.strand == "+")
{
chip.signal.means[i, ] <- colMeans(chip.signal[[i]],na.rm = TRUE)
} else if (target.gene.strand == "-")
{
chip.signal.means[i, ] <- rev(colMeans(chip.signal[[i]],na.rm = TRUE))
}
}
## Draw peak regions for each TF and determing TF binding sequences
## Determine TFBS motifs to search for
if(input$all.motifs)
{
selected.motifs.pwm <- motifs.pwm
} else
{
selected.motifs.pwm <- motifs.pwm[input$selected.motifs]
}
selected.motif.names <- names(selected.motifs.pwm)
selected.motif.ids <- motif.ids[selected.motif.names]
## Initialize data frame containing TF binding sequences in the peak regions
df.hits <- data.frame(0,0,"","","")
colnames(df.hits) <- c("tf_number","position","id","name","seq")
## Width of the rectangule representing the peak reagion
peak.width <- 1
for(i in 1:number.tfs)
{
## Extract bed file name 1 and read it
current.bed.file <- selected.bed.files[i]
current.peaks <- read.table(file=current.bed.file,header = F, as.is = T)
peak.coordinates <- subset(current.peaks, V1 == range.to.plot$seqnames & V2 >= range.to.plot$start & V3 <= range.to.plot$end)
current.peaks.to.plot <- peak.coordinates[,2:3]
## Transform coordinates
current.peaks.to.plot <- current.peaks.to.plot - range.to.plot$start
## Check if there are peaks for the target gene
if(nrow(current.peaks.to.plot) > 0)
{
## Normalization
chip.signal.means[i, ] <- 10 * chip.signal.means[i, ] / max(chip.signal.means[i, ])
#motifs.in.peaks <- vector(mode="list", length=nrow(current.peaks.to.plot))
for(j in 1:nrow(current.peaks.to.plot))
{
## Extract start and end point of each peak region
current.peak.start <- current.peaks.to.plot[j,1]
current.peak.end <- current.peaks.to.plot[j,2]
## Computer coordinates for polygon and draw it
peak.x <- c(current.peak.start,current.peak.end,
current.peak.end,current.peak.start)
peak.y <- c(25*(i - 1) - 5 + peak.width, 25*(i - 1) - 5 + peak.width,
25*(i - 1) - 5 - peak.width, 25*(i - 1) - 5 - peak.width)
polygon(x = peak.x, y = peak.y, col = area.colors[i], border = line.colors[i],lwd=2)
## Identify TF binding DNA motifs
peak.chr <- peak.coordinates[j, 1]
peak.start <- peak.coordinates[j, 2]
peak.end <- peak.coordinates[j, 3]
## Extract peak sequence
if(peak.chr == "1")
{
peak.sequence <- c2s(chr1[peak.start:peak.end])
} else if(peak.chr == "2")
{
peak.sequence <- c2s(chr2[peak.start:peak.end])
} else if(peak.chr == "3")
{
peak.sequence <- c2s(chr3[peak.start:peak.end])
} else if(peak.chr == "4")
{
peak.sequence <- c2s(chr4[peak.start:peak.end])
} else if(peak.chr == "5")
{
peak.sequence <- c2s(chr5[peak.start:peak.end])
}
peak.rev.comp.sequence <- reverse.complement(peak.sequence)
for(k in 1:length(selected.motifs.pwm))
{
motif.pwm <- selected.motifs.pwm[[k]]
hits.fw <- matchPWM(motif.pwm, peak.sequence,
min.score = paste0(input$min.score.pwm,"%"))
hits.fw.seqs <- as.data.frame(hits.fw)[[1]]
hits.fw <- as(hits.fw, "IRanges")
hits.fw.start <- start(hits.fw)
hits.fw.end <- end(hits.fw)
if(length(hits.fw.start) > 0)
{
df.hits.fw <- data.frame(rep(i,length(hits.fw.start)),
((hits.fw.start+hits.fw.end)/2) + current.peak.start,
rep(selected.motif.ids[k],length(hits.fw.start)),
rep(selected.motif.names[k],length(hits.fw.start)),
hits.fw.seqs)
colnames(df.hits.fw)  <- c("tf_number","position","id","name","seq")
df.hits <- rbind(df.hits,df.hits.fw)
}
hits.rev <- matchPWM(motif.pwm, peak.rev.comp.sequence,
min.score = paste0(input$min.score.pwm,"%"))
hits.rev.seqs <- as.data.frame(hits.rev)[[1]]
hits.rev.seqs <- sapply(hits.rev.seqs,reverse.complement)
names(hits.rev.seqs) <- NULL
hits.rev <- as(hits.rev, "IRanges")
hits.rev.start <- nchar(peak.sequence) - end(hits.rev) + 1
hits.rev.end <- nchar(peak.sequence) - start(hits.rev) + 1
if(length(hits.rev.start) > 0)
{
df.hits.rev <- data.frame(rep(i,length(hits.rev.start)),
((hits.rev.start+hits.rev.end)/2) + current.peak.start,
rep(selected.motif.ids[k],length(hits.rev.start)),
rep(selected.motif.names[k],length(hits.rev.start)),
hits.rev.seqs)
colnames(df.hits.rev)  <- c("tf_number","position","id","name","seq")
df.hits <- rbind(df.hits,df.hits.rev)
}
}
}
}
}
## Remove first line of the data frame added just for technical reason
df.hits <- df.hits[-1,]
## Draw TF binding sites
detected.tfbs <- unique(as.vector(df.hits$name))
number.of.shapes <- ceiling(length(detected.tfbs) / length(symbol.color))
necessary.shapes <- rep(symbol.shapes[1:number.of.shapes],each = length(detected.tfbs)/number.of.shapes)
necessary.colors <- rep(symbol.color,number.of.shapes)
if(length(detected.tfbs) > 0)
{
for(i in 1:length(detected.tfbs))
{
current.tfbs <- detected.tfbs[i]
current.shape <- necessary.shapes[i]
current.color <- necessary.colors[i]
positions <- subset(df.hits, name == current.tfbs)
for(j in 1:nrow(positions))
{
tf.to.draw <- positions$tf_number[j]
pos.to.draw <- positions$position[j]
points(x = pos.to.draw, y = 25*(tf.to.draw - 1) - 5 - 5*peak.width,
pch = current.shape, col = current.color, cex = 1)
}
}
## Add legend for TFBS
legend.step <- 10
for(i in 1:length(detected.tfbs))
{
points(x = -3000, y = upper.lim - (i-1)*legend.step,
pch=necessary.shapes[i], col = necessary.colors[i],cex = 1)
current.seq <- as.character(subset(df.hits,name == detected.tfbs[i])[["seq"]][[1]])
current.label <- paste(c(detected.tfbs[i], "  -  ", current.seq ),collapse="")
text(x = -2900, y = upper.lim - (i-1)*legend.step, labels = current.label,
adj = 0,cex = 0.7)
}
}
## Draw profiles for TF binding
for(i in 1:number.tfs)
{
## Compute base line for current TF
current.base.line <- 25 * (i - 1)
## Represent signal from the current TF
lines(chip.signal.means[i,]+current.base.line,type="l",col=line.colors[i],lwd=3)
## Determine polygon coordinates and represent it
cord.y <- c(current.base.line,chip.signal.means[i,]+current.base.line,current.base.line)
cord.x <- 1:length(cord.y)
polygon(cord.x,cord.y,col=area.colors[i])
text(x = -50,y = 25*(i-1) + 12,labels = input$names.tfs[i],adj = 1,col = line.colors[i],font = 2)
}
})
number.tfs
i <- 1
## Compute base line for current TF
current.base.line <- 25 * (i - 1)
## Represent signal from the current TF
lines(chip.signal.means[i,]+current.base.line,type="l",col=line.colors[i],lwd=3)
## Determine polygon coordinates and represent it
cord.y <- c(current.base.line,chip.signal.means[i,]+current.base.line,current.base.line)
cord.x <- 1:length(cord.y)
polygon(cord.x,cord.y,col=area.colors[i])
text(x = -50,y = 25*(i-1) + 12,labels = input$names.tfs[i],adj = 1,col = line.colors[i],font = 2)
i <- 2
chip.signal.means[i,]
current.base.line
chip.signal.means[i,]
cord.x
cord.y
i
i <- 1
## Compute base line for current TF
current.base.line <- 25 * (i - 1)
current.base.line
chip.signal.means[i,]
chip.signal
i <- 1
chip.signal.means[i, ]
colMeans(chip.signal[[i]],na.rm = TRUE)
chip.signal[[i]]
chip.signal[[1]]
chip.signal[[1]][1:4,1:5]
dim(chip.signal[[1]])
chip.signal[[1]][1:4,1:2]
chip.signal[[1]][1:2,1:5]
chip.signal[[1]][1:2,1:100]
chip.signal[[1]][1:2,1:10000]
chip.signal[[1]][1:2,1:1000]
