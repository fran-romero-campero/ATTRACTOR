keys=keys(org.At.tair.db, keytype="ENTREZID "),
columns=c("SYMBOL", "TAIR"), keytype="ENTREZID")
## Load all and circadian genes
alias2symbol.table <- AnnotationDbi::select(org.At.tair.db,
keys=keys(org.At.tair.db, keytype="ENTREZID"),
columns=c("SYMBOL", "TAIR"), keytype="ENTREZID")
runApp()
runApp('~/Dropbox/github_repos/ATTRACTOR/web_apps/attractor_dev')
runApp()
runApp()
runApp('~/Dropbox/github_repos/ATTRACTOR/web_apps/individual_genes')
runApp('~/Dropbox/github_repos/ATTRACTOR/web_apps/individual_genes')
runApp('~/Dropbox/github_repos/ATTRACTOR/web_apps/individual_genes')
runApp('~/Dropbox/github_repos/ATTRACTOR/web_apps/individual_genes')
runApp('~/Dropbox/github_repos/ATTRACTOR/web_apps/individual_genes')
runApp('~/Dropbox/github_repos/ATTRACTOR/web_apps/individual_genes')
runApp('~/Dropbox/github_repos/ATTRACTOR/web_apps/individual_genes')
runApp('~/Dropbox/github_repos/ATTRACTOR/web_apps/individual_genes')
shiny::runApp()
runApp()
setwd("~/Dropbox/github_repos/ATTRACTOR/web_apps/network_visualizer")
library(shiny)
library(org.At.tair.db)
library(igraph)
## Colors used to represent repression/activation/neutrality
repressor.color <- "firebrick1"
activator.color <- "seagreen3"
neutral.color <- "lightgrey"
## Auxiliary function to determine surronding ZTs
zts.to.consider <- function(zt.point)
{
zts <- c("ZT00","ZT04","ZT08","ZT12","ZT16","ZT20")
zts.numeric <- seq(from=0,to=20,by=4)
if(zt.point %in% zts.numeric)
{
return(c(zt.point,zt.point))
} else
{
#current.zt.numeric <- as.numeric(substr(zt.point,start=3,stop=nchar(current.regulator.zt)))
next.zt <- zts.numeric[which(zts.numeric >= zt.point)[1]]
previous.zt <- zts.numeric[which(zts.numeric >= zt.point)[1] - 1]
return(c(previous.zt, next.zt))
}
}
##Parameters
radius.1 <- 100 #Outer circle radius
height <- 4 ## highest point in ylim for profile plot
## Read graph adjacency matrix
network.data <- read.table(file="../attractor_dev/data/attractor_network_representation.tsv",header = TRUE,as.is=TRUE,sep="\t",quote = "")
# columns(org.At.tair.db)
## Extract gene ids
genes <- sort(network.data$name)
length(genes)
## Load all and circadian genes
alias2symbol.table <- AnnotationDbi::select(org.At.tair.db,
keys=keys(org.At.tair.db, keytype="ENTREZID"),
columns=c("SYMBOL", "TAIR"), keytype="ENTREZID")
alias2symbol.table <- subset(alias2symbol.table, genes %in% TAIR)
alias <- alias2symbol.table$SYMBOL
names(alias) <- alias2symbol.table$TAIR
alias[is.na(alias)] <- ""
# alias <- alias[genes]
genes.selectize <- paste(names(alias), alias, sep=" - ")
length(genes.selectize)
runApp()
runApp()
target.agi <- "AT1G22770"
selected.tfs.agi <- "AT2G46830"
to.keep <- rep(FALSE,ncol(adj.global.matrix))
## Read graph adjacency matrix
network.data <- read.table(file="../attractor_dev/data/attractor_network_representation.tsv",header = TRUE,as.is=TRUE,sep="\t",quote = "")
adj.global.matrix <- as.matrix(network.data[,35:53])
rownames(adj.global.matrix) <- network.data$names
to.keep <- rep(FALSE,ncol(adj.global.matrix))
to.keep
for(i in 1:length(input$selected.tfs))
{
to.keep <- (to.keep | grepl(input$selected.tfs[i],colnames(adj.global.matrix)))
}
i <- 1
to.keep <- (to.keep | grepl(input$selected.tfs[i],colnames(adj.global.matrix)))
to.keep <- (to.keep | grepl(selected.tfs[i],colnames(adj.global.matrix)))
selected.tfs <- "CCA1"
to.keep <- (to.keep | grepl(selected.tfs[i],colnames(adj.global.matrix)))
to.keep <- (to.keep | grepl(input$selected.tfs[i],colnames(adj.global.matrix)))
to.keep
##First, modify the adj matrix to keep only the selected tfs marked in the app
adj.matrix.to.represent <- as.matrix(adj.global.matrix[selected.tfs.agi,to.keep])
adj.matrix.to.represent
if(nrow(adj.matrix.to.represent) == 1)
{
rownames(adj.matrix.to.represent) <- selected.tfs.agi
colnames(adj.matrix.to.represent) <- colnames(adj.global.matrix)[to.keep]
}
new.row.names <- c()
updated.adj.matrix.to.represent <- c()
# if(nrow(adj.matrix.to.represent) > 0)
# {
#   print("hey hey")
for(i in 1:nrow(adj.matrix.to.represent))
{
current.tf.name <- name.tfs[rownames(adj.matrix.to.represent)[i]]
current.tf.zts <- agi.tfs.zts[[rownames(adj.matrix.to.represent)[i]]]
current.tf.name.zt <- paste(current.tf.name,current.tf.zts,sep="_")
new.row.names <- c(new.row.names,current.tf.name.zt)
if(length(current.tf.zts) > 1)
{
updated.adj.matrix.to.represent <- rbind(
rbind(updated.adj.matrix.to.represent,
adj.matrix.to.represent[i,]),
adj.matrix.to.represent[i,])
} else
{
updated.adj.matrix.to.represent <- rbind(updated.adj.matrix.to.represent,
adj.matrix.to.represent[i,])
}
}
## Read graph adjacency matrix
agi.tfs <- c("AT2G46830", "AT1G01060", "AT5G61380", "AT5G24470", "AT5G02810", "AT2G46790","AT1G09570",
"AT2G18790", "AT1G04400", "AT2G37678", "AT3G46640", "AT1G09530", "AT2G43010", "AT3G59060",
"AT2G40080", "AT2G25930")
name.tfs <- c("CCA1", "LHY",  "TOC1", "PRR5", "PRR7", "PRR9", "PHYA", "PHYB", "CRY2", "FHY1", "LUX", "PIF3",
"PIF4", "PIF5", "ELF4", "ELF3")
# if(nrow(adj.matrix.to.represent) > 0)
# {
#   print("hey hey")
for(i in 1:nrow(adj.matrix.to.represent))
{
current.tf.name <- name.tfs[rownames(adj.matrix.to.represent)[i]]
current.tf.zts <- agi.tfs.zts[[rownames(adj.matrix.to.represent)[i]]]
current.tf.name.zt <- paste(current.tf.name,current.tf.zts,sep="_")
new.row.names <- c(new.row.names,current.tf.name.zt)
if(length(current.tf.zts) > 1)
{
updated.adj.matrix.to.represent <- rbind(
rbind(updated.adj.matrix.to.represent,
adj.matrix.to.represent[i,]),
adj.matrix.to.represent[i,])
} else
{
updated.adj.matrix.to.represent <- rbind(updated.adj.matrix.to.represent,
adj.matrix.to.represent[i,])
}
}
agi.tfs.zts <- list(c("ZT02","ZT14"),
c("ZT02"),c("ZT15"),c("ZT10"),c("ZT12"),c("ZT04"),c("ZT00"),c("ZT00"),
c("ZT08"),c("ZT04"),c("ZT10","ZT12"),c("ZT08"),c("ZT04"),c("ZT04"),
c("ZT10"),c("ZT00","ZT04"))
tfs.selectize <- c("CCA1", "LHY",  "TOC1", "PRR5", "PRR7", "PRR9", "PHYA", "PHYB", "CRY2", "FHY1", "LUX", "PIF3",
"PIF4", "PIF5", "ELF4", "ELF3")
# if(nrow(adj.matrix.to.represent) > 0)
# {
#   print("hey hey")
for(i in 1:nrow(adj.matrix.to.represent))
{
current.tf.name <- name.tfs[rownames(adj.matrix.to.represent)[i]]
current.tf.zts <- agi.tfs.zts[[rownames(adj.matrix.to.represent)[i]]]
current.tf.name.zt <- paste(current.tf.name,current.tf.zts,sep="_")
new.row.names <- c(new.row.names,current.tf.name.zt)
if(length(current.tf.zts) > 1)
{
updated.adj.matrix.to.represent <- rbind(
rbind(updated.adj.matrix.to.represent,
adj.matrix.to.represent[i,]),
adj.matrix.to.represent[i,])
} else
{
updated.adj.matrix.to.represent <- rbind(updated.adj.matrix.to.represent,
adj.matrix.to.represent[i,])
}
}
rownames(updated.adj.matrix.to.represent) <- new.row.names
updated.adj.matrix.to.represent
new.row.names
current.tf.name <- name.tfs[rownames(adj.matrix.to.represent)[i]]
current.tf.name
adj.matrix.to.represent
rownames(adj.matrix.to.represent)
[rownames(adj.matrix.to.represent)[i]]
name.tfs[rownames(adj.matrix.to.represent)[i]]
rownames(adj.matrix.to.represent)
rownames(adj.matrix.to.represent)[i]
name.tfs[rownames(adj.matrix.to.represent)[i]]
name.tfs["PRR9"]
current.tf.name <- name.tfs[rownames(adj.matrix.to.represent)[i]]
current.tf.zts <- agi.tfs.zts[[rownames(adj.matrix.to.represent)[i]]]
current.tf.name
current.tf.zts
name.tfs
agi.tfs.zts
sel.tfs <- c("LHY","CRY2","PIF3","PHYA","PHYB","ELF3","FHY1","ELF4","PIF4","PRR9","CCA1","LUX","PIF5","PRR7","PRR5","TOC1")
to.keep <- rep(TRUE,ncol(adj.global.matrix))
selected.tfs.agi <- agis[sel.tfs]
agi.tfs <- c("AT2G46830", "AT1G01060", "AT5G61380", "AT5G24470", "AT5G02810", "AT2G46790","AT1G09570",
"AT2G18790", "AT1G04400", "AT2G37678", "AT3G46640", "AT1G09530", "AT2G43010", "AT3G59060",
"AT2G40080", "AT2G25930")
name.tfs <- c("CCA1", "LHY",  "TOC1", "PRR5", "PRR7", "PRR9", "PHYA", "PHYB", "CRY2", "FHY1", "LUX", "PIF3",
"PIF4", "PIF5", "ELF4", "ELF3")
agi.tfs.zts <- list(c("ZT02","ZT14"),
c("ZT02"),c("ZT15"),c("ZT10"),c("ZT12"),c("ZT04"),c("ZT00"),c("ZT00"),
c("ZT08"),c("ZT04"),c("ZT10","ZT12"),c("ZT08"),c("ZT04"),c("ZT04"),
c("ZT10"),c("ZT00","ZT04"))
tfs.selectize <- c("CCA1", "LHY",  "TOC1", "PRR5", "PRR7", "PRR9", "PHYA", "PHYB", "CRY2", "FHY1", "LUX", "PIF3",
"PIF4", "PIF5", "ELF4", "ELF3")
agi.tfs.zts.multiplicity <- sapply(agi.tfs.zts,length)
names(agi.tfs.zts) <- agi.tfs
names(agi.tfs.zts.multiplicity) <- agi.tfs
names(name.tfs) <- agi.tfs
## Read regulation data
regulation.matrix <- as.matrix(network.data[,35:53])
rownames(regulation.matrix) <- network.data$names
adj.matrix <- as.matrix(network.data[,35:53])
rownames(adj.matrix) <- network.data$names
adj.matrix <- adj.matrix[agi.tfs,]
## Extract TF targets
cca1.tf.targets <- adj.matrix[,"CCA1_ZT02"] + adj.matrix[,"CCA1_ZT14"]
lhy.tf.targets <- adj.matrix[,"LHY_ZT02"]
toc1.tf.targets <- adj.matrix[,"TOC1_ZT15"]
prr5.tf.targets <- adj.matrix[,"PRR5_ZT10"]
prr7.tf.targets <- adj.matrix[,"PRR7_ZT12"]
prr9.tf.targets <- adj.matrix[,"PRR9_ZT04"]
phya.tf.targets <- adj.matrix[,"PHYA_ZT00"]
phyb.tf.targets <- adj.matrix[,"PHYB_ZT00"]
cry2.tf.targets <- adj.matrix[,"CRY2_ZT08"]
fhy1.tf.targets <- adj.matrix[,"FHY1_ZT04"]
lux.tf.targets <- adj.matrix[,"LUX_ZT10"] + adj.matrix[,"LUX_ZT12"]
pif3.tf.targets <- adj.matrix[,"PIF3_ZT08"]
pif4.tf.targets <- adj.matrix[,"PIF4_ZT04"]
pif5.tf.targets <- adj.matrix[,"PIF5_ZT04"]
elf4.tf.targets <- adj.matrix[,"ELF4_ZT10"]
elf3.tf.targets <- adj.matrix[,"ELF3_ZT00"] + adj.matrix[,"ELF3_ZT04"]
adj.matrix <- matrix(c(cca1.tf.targets, lhy.tf.targets, toc1.tf.targets, prr5.tf.targets, prr7.tf.targets,
prr9.tf.targets, phya.tf.targets, phyb.tf.targets, cry2.tf.targets, fhy1.tf.targets,
lux.tf.targets, pif3.tf.targets, pif4.tf.targets, pif5.tf.targets, elf4.tf.targets,
elf3.tf.targets),ncol=16,nrow=16)
colnames(adj.matrix) <- agi.tfs
rownames(adj.matrix) <- agi.tfs
sel.tfs <- c("LHY","CRY2","PIF3","PHYA","PHYB","ELF3","FHY1","ELF4","PIF4","PRR9","CCA1","LUX","PIF5","PRR7","PRR5","TOC1")
to.keep <- rep(TRUE,ncol(adj.global.matrix))
selected.tfs.agi <- agis[sel.tfs]
alias2symbol.table <- AnnotationDbi::select(org.At.tair.db,
keys=keys(org.At.tair.db, keytype="ENTREZID"),
columns=c("SYMBOL", "TAIR"), keytype="ENTREZID")
alias2symbol.table <- subset(alias2symbol.table, genes %in% TAIR)
alias <- alias2symbol.table$SYMBOL
names(alias) <- alias2symbol.table$TAIR
alias[is.na(alias)] <- ""
alias <- alias[genes]
genes.selectize <- paste(names(alias), alias, sep=" - ")
agis <-alias2symbol.table$TAIR
names(agis) <- alias2symbol.table$SYMBOL
agis[is.na(agis)] <- ""
sel.tfs <- c("LHY","CRY2","PIF3","PHYA","PHYB","ELF3","FHY1","ELF4","PIF4","PRR9","CCA1","LUX","PIF5","PRR7","PRR5","TOC1")
to.keep <- rep(TRUE,ncol(adj.global.matrix))
selected.tfs.agi <- agis[sel.tfs]
selected.tfs.agi
selected.tfs.agi <- "AT2G46830"
target.agi
nrow(adj.matrix.to.represent)
# if(nrow(adj.matrix.to.represent) > 0)
# {
#   print("hey hey")
for(i in 1:nrow(adj.matrix.to.represent))
{
current.tf.name <- name.tfs[rownames(adj.matrix.to.represent)[i]]
current.tf.zts <- agi.tfs.zts[[rownames(adj.matrix.to.represent)[i]]]
current.tf.name.zt <- paste(current.tf.name,current.tf.zts,sep="_")
new.row.names <- c(new.row.names,current.tf.name.zt)
if(length(current.tf.zts) > 1)
{
updated.adj.matrix.to.represent <- rbind(
rbind(updated.adj.matrix.to.represent,
adj.matrix.to.represent[i,]),
adj.matrix.to.represent[i,])
} else
{
updated.adj.matrix.to.represent <- rbind(updated.adj.matrix.to.represent,
adj.matrix.to.represent[i,])
}
}
new.row.names
current.tf.name
name.tfs
rownames(adj.matrix.to.represent)
rownames(adj.matrix.to.represent)[i]
rownames(adj.matrix.to.represent)[i]
strsplit(x = rownames(adj.matrix.to.represent)[i], split = "_")
strsplit(x = rownames(adj.matrix.to.represent)[i], split = "_")[[1]]
strsplit(x = rownames(adj.matrix.to.represent)[i], split = "_")[[1]][1]
current.tf.name <- strsplit(x = rownames(adj.matrix.to.represent)[i], split = "_")[[1]][1]
current.tf.name
# current.tf.name <- name.tfs[rownames(adj.matrix.to.represent)[i]]
current.tf.zts <- agi.tfs.zts[[rownames(adj.matrix.to.represent)[i]]]
current.tf.zts
rownames(adj.matrix.to.represent)
rownames(adj.matrix.to.represent)[i]]
rownames(adj.matrix.to.represent)[i]
agi.tfs.zts
# current.tf.name <- name.tfs[rownames(adj.matrix.to.represent)[i]]
agis(current.tf.name)
# current.tf.name <- name.tfs[rownames(adj.matrix.to.represent)[i]]
agis[current.tf.name]
# current.tf.name <- name.tfs[rownames(adj.matrix.to.represent)[i]]
agi.tfs.zts[agis[current.tf.name][i]]
agis[current.tf.name][i]
current.tf.name
agis[current.tf.name]
# current.tf.name <- name.tfs[rownames(adj.matrix.to.represent)[i]]
agi.tfs.zts[agis[current.tf.name]
current.tf.zts <- agi.tfs.zts[[rownames(adj.matrix.to.represent)[i]]]
current.tf.name.zt <- paste(current.tf.name,current.tf.zts,sep="_")
new.row.names <- c(new.row.names,current.tf.name.zt)
if(length(current.tf.zts) > 1)
{
updated.adj.matrix.to.represent <- rbind(
rbind(updated.adj.matrix.to.represent,
adj.matrix.to.represent[i,]),
adj.matrix.to.represent[i,])
} else
{
updated.adj.matrix.to.represent <- rbind(updated.adj.matrix.to.represent,
adj.matrix.to.represent[i,])
}
}
rownames(updated.adj.matrix.to.represent) <- new.row.names
# } else
# {
#   updated.adj.matrix.to.represent <- adj.matrix.to.represent
# }
updated.adj.matrix.to.represent <- rbind(updated.adj.matrix.to.represent,adj.global.matrix[target.agi,to.keep])
updated.adj.matrix.to.represent <- cbind(updated.adj.matrix.to.represent,rep(0,nrow(updated.adj.matrix.to.represent)))
#rows.cols.to.keep <- unlist(sapply(to.keep, grep, row.names(adj.matrix)))
#tf.adj.matrix <- adj.matrix[rows.cols.to.keep,rows.cols.to.keep]
#Modify adj.matrix and matrix.pos to add the target.gene
gene.peak.str <- subset(network.data, names == target.agi)$peak.zt
gene.peak <- as.numeric(substr(x=gene.peak.str,start=5,stop=nchar(gene.peak.str)))
#gene.row.complete <- adj.global.matrix[target.agi,]
#gene.row <- gene.row[rows.cols.to.keep] #remove non selected tfs from the added row
target.color <- selected.colors[paste0("peak",gene.peak)]
if (input$interactions == "Yes")
{
#To show the interactions between the TFs too
#new.matrix <- cbind(tf.adj.matrix, gene.row)
#new.matrix <- rbind(new.matrix, rep(0,ncol(new.matrix)))
new.matrix <- t(updated.adj.matrix.to.represent)
} else {
#To show only the interactions between the TFs and the selected gene.
number.tfs <- nrow(updated.adj.matrix.to.represent) - 1
new.matrix <- updated.adj.matrix.to.represent
new.matrix[1:number.tfs,] <- 0
colnames(new.matrix)[number.tfs+1] <- alias[target.agi]
rownames(new.matrix)[number.tfs+1] <- alias[target.agi]
new.matrix <- t(new.matrix)
# rownames.matrix <- row.names(adj.matrix)
# null.matrix <- matrix(data = rep(x = 0, times=length(rownames.matrix)^2),
#                       byrow = TRUE, ncol = length(rownames.matrix), nrow = length(rownames.matrix))
# rownames(null.matrix) <- rownames.matrix
# colnames(null.matrix) <- rownames.matrix
# new.matrix <- cbind(null.matrix, gene.row)
# new.matrix <- rbind(new.matrix, rep(0,ncol(new.matrix)))
}
#Generating the complete network
tfs.network <- graph.adjacency(adjmatrix = new.matrix, mode = "directed",weighted = TRUE)
edge.weights <- E(tfs.network)$weight
## Edge colors
for(k in 1:length(edge.weights))
{
if(edge.weights[k] == 1)
{
E(tfs.network)$color[k] <- activator.color #"darkgreen"
} else if(edge.weights[k] == -1)
{
E(tfs.network)$color[k] <- repressor.color  #"darkred"
} else if(edge.weights[k] == 2)
{
print(1)
E(tfs.network)$color[k] <- neutral.color
}
}
## Vertex colors
node.colors <- vector(mode="character",length=nrow(new.matrix))
for(k in 1:(length(node.colors)-1))
{
if(new.matrix[k,ncol(new.matrix)] == 1)
{
node.colors[k] <- activator.color
} else if(new.matrix[k,ncol(new.matrix)] == -1)
{
node.colors[k] <- repressor.color
} else #if (new.matrix[k,ncol(new.matrix)] == 0)
{
node.colors[k] <- neutral.color
}
}
node.colors[length(node.colors)] <- target.color
#First, modify the angles, radius, and labels positions to keep only
#the selected tfs
tfs.angles <- tfs.angles[to.keep]
radius.to.multiply <- radius.to.multiply[to.keep]
node.labels <- node.labels[to.keep]
#Modify the angles, the radius and the positions to add the new node
new.tfs.angles <- c(tfs.angles, radian.conversion(gene.peak*15))
new.multiply <- c(radius.to.multiply, radius.1*0.3)
tfs.x <- new.multiply * sin(new.tfs.angles)
tfs.y <- new.multiply * cos(new.tfs.angles)
new.matrix.pos <- matrix(data = c(tfs.x, tfs.y), nrow = nrow(new.matrix), ncol = 2)
new.node.labels <- c(node.labels, alias[target.agi])
#Plot the network
#par(mar = c(4,4,4,4))
print(2)
print(node.colors)
plot.igraph(tfs.network, layout=new.matrix.pos, add = TRUE, rescale=FALSE, vertex.size=radius.1*13,
vertex.color = node.colors, vertex.label=new.node.labels, edge.arrow.size = 0.8,
edge.arrow.width=2, edge.curved= TRUE, edge.width = 4, vertex.label.dist = 0,
vertex.label.cex=1, vertex.label.font=2,vertex.label.color="black",label.font=2)
print(3)
# } else {
#   #par(mar = c(0,0,0,0))
#   plot(c(0, 1), c(0, 1), ann = F, bty = 'n', type = 'n', xaxt = 'n', yaxt = 'n')
#   text(x=0.5, y = 0.5, paste("The", target.agi, "gene does not present a circadian expression pattern"), cex = 0.7)
# }
#
}, height = 650, width = 650)
})
observeEvent(eventExpr = input$button, handlerExpr = {
output$expression <- renderPlot({
target.agi <- strsplit(x = input$target.gene, split = " - ")[[1]][1]
#Error message for the user
if(input$all == FALSE)
{
validate(
need(input$selected.tfs, "Please select some transcription factor")
)
}
target.agi <- strsplit(x = input$target.gene, split = " - ")[[1]][1]
gene.expression <- as.vector(scale(mean.expression[target.agi,]))
gene.expression <- c(gene.expression, gene.expression[1])
extended.gene.expression <- approx(x = seq(from=0,to=24,by=4), y = gene.expression, xout=c(0,2,4,8,10,12,14,15,16,20,24))
extended.gene.expression.values <- extended.gene.expression$y
names(extended.gene.expression.values) <- c("ZT00", "ZT02", "ZT04", "ZT08", "ZT10", "ZT12", "ZT14", "ZT15", "ZT16", "ZT20", "ZT24")
plot(x=seq(from=0,to=24,by=4),gene.expression,
type="o",lwd=5,cex=1.5,
ylim=c(-2.5,height),xlim=c(0,24),
col="darkgrey",axes=FALSE,xlab="",ylab="",
main=paste(target.agi, alias[target.agi],sep=" - "))
## Add TFs to expression profile
if (input$all){
sel.tfs <- c("LHY","CRY2","PIF3","PHYA","PHYB","ELF3","FHY1","ELF4","PIF4","PRR9","CCA1","LUX","PIF5","PRR7","PRR5","TOC1")
selected.tfs.agi <- agis[sel.tfs]
} else {
selected.tfs.agi <- agis[input$selected.tfs]
}
for(i in 1:length(selected.tfs.agi))
{
current.tf.name <- names(selected.tfs.agi[i])
current.tf.zts <- agi.tfs.zts[selected.tfs.agi[i]][[1]]
# current.time.points <- vector(mode="numeric",length=length(current.tf.zts))
for(j in 1:length(current.tf.zts))
{
current.time.point <- as.numeric(substr(x = current.tf.zts[j], start = 3, stop = nchar(current.tf.zts[j])))
current.tf.zt <- paste(current.tf.name,current.tf.zts[j],sep="_")
current.regulation <- regulation.matrix[target.agi,current.tf.zt]
if(current.regulation == 1)
{
point.color <- activator.color #"seagreen3"#"darkgreen"
arrow.angle <- 45
draw.tf <- TRUE
} else if (current.regulation == -1)
{
point.color <- repressor.color # "firebrick1"
arrow.angle <- 90
draw.tf <- TRUE
} else if (current.regulation == 2)
{
point.color <- neutral.color
arrow.angle <- 45
draw.tf <- TRUE
} else if (current.regulation == 0)
{
draw.tf <- FALSE
}
if(draw.tf)
{
arrows(x0 = current.time.point, y0 = height.to.multiply[current.tf.zt],
x1 = current.time.point ,y1= extended.gene.expression.values[current.tf.zts[j]] + 0.3,lwd=4,angle=arrow.angle,length=0.05,col=point.color)
points(x = current.time.point,y=height.to.multiply[current.tf.zt],lwd=4,cex=4, col=point.color, pch = 19)
text(x = current.time.point,y=height.to.multiply[current.tf.zt],labels = current.tf.name, cex=1.2, font=2 )
}
}
}
polygon(x=c(0,12,12,0),y=c(-2,-2,-2.3,-2.3),lwd=2)
polygon(x=c(12,24,24,12),y=c(-2,-2,-2.3,-2.3),col = "black",lwd=2)
axis(side = 2,at = -2:2,labels = FALSE,lwd=2)
mtext("Normalized Gene Expression",side = 2,line = 1.3,cex = 1.3,at = 0)
axis(side = 1,at=seq(from=0,to=24,by=2),line=-1,las=2,labels = paste("ZT",seq(from=0,to=24,by=2),sep=""),lwd=2)
}, height = 600)
})
}
# Run the application
shinyApp(ui = ui, server = server)
# current.tf.name <- name.tfs[rownames(adj.matrix.to.represent)[i]]
agi.tfs.zts[agis[current.tf.name]]
current.tf.name <- strsplit(x = rownames(adj.matrix.to.represent)[i], split = "_")[[1]][1]
# current.tf.name <- name.tfs[rownames(adj.matrix.to.represent)[i]]
current.tf.zts <- agi.tfs.zts[agis[current.tf.name]]
# current.tf.zts <- agi.tfs.zts[[rownames(adj.matrix.to.represent)[i]]]
current.tf.name.zt <- paste(current.tf.name,current.tf.zts,sep="_")
current.tf.name.zt
current.tf.name <- strsplit(x = rownames(adj.matrix.to.represent)[i], split = "_")[[1]][1]
current.tf.name
runApp()
runApp()
