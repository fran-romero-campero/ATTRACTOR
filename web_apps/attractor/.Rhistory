hora <- hora + increment
}
}
plot(time.points,var.cosw)
start.time <- 9
end.time <- 1
if(end.time > start.time)
{
factor.hora <- 180/(end.time - start.time)
max.time <- (start.time + end.time)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time && hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
} else
{
day.length <- (24 - start.time) + end.time
factor.hora <- 180/(day.length)
max.time <- start.time + (day.length)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time || hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
}
plot(time.points,var.cosw)
day.length <- (24 - start.time) + end.time
day.length
factor.hora <- 180/(day.length)
max.time <- start.time + (day.length)/2
max.time
start.time <- 9
end.time <- 1
if(end.time > start.time)
{
factor.hora <- 180/(end.time - start.time)
max.time <- (start.time + end.time)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time && hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
} else
{
day.length <- (24 - start.time) + end.time
factor.hora <- 180/(day.length)
max.time <- start.time + (day.length)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else if(hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - 24 + hora)/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
}
plot(time.points,var.cosw)
start.time <- 9
end.time <- 1
if(end.time > start.time)
{
factor.hora <- 180/(end.time - start.time)
max.time <- (start.time + end.time)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time && hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
} else
{
day.length <- (24 - start.time) + end.time
factor.hora <- 180/(day.length)
max.time <- start.time + (day.length)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else if(hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - 24 - hora)/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
}
plot(time.points,var.cosw)
start.time <- 9
end.time <- 1
if(end.time > start.time)
{
factor.hora <- 180/(end.time - start.time)
max.time <- (start.time + end.time)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time && hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
} else
{
day.length <- (24 - start.time) + end.time
factor.hora <- 180/(day.length)
max.time <- start.time + (day.length)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else if(hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - (hora+24))/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
}
plot(time.points,var.cosw)
start.time <- 10
end.time <- 2
if(end.time > start.time)
{
factor.hora <- 180/(end.time - start.time)
max.time <- (start.time + end.time)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time && hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
} else
{
day.length <- (24 - start.time) + end.time
factor.hora <- 180/(day.length)
max.time <- start.time + (day.length)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else if(hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - (hora+24))/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
}
plot(time.points,var.cosw)
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/Pedro_de_los_Reyes/arabidopsis_thaliana_clock_network/web_apps/network_visualizer')
runApp('Dropbox/Pedro_de_los_Reyes/arabidopsis_thaliana_clock_network/web_apps/peak_visualizer')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("ChIPseeker", version = "3.8")
BiocManager::install("ChIPseeker", version = "3.8")
BiocManager::install("ChIPseeker", version = "3.8")
library("ChIPSeeker")
BiocManager::install("ChIPseeker", version = "3.8")
library("ChIPSeeker")
library("ChIPseeker")
options(repos = BiocInstaller::biocinstallRepos())
getOption("repos")
rsconnect::appDependencies()
options(rsconnect.max.bundle.size=3145728000)
rsconnect::appDependencies()
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("BiocGenerics", version = "3.8")
options(repos = BiocInstaller::biocinstallRepos())
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("BiocInstaller", version = "3.8")
options(repos = BiocInstaller::biocinstallRepos())
getOption("repos")
shiny::runApp('Dropbox/ATTRACTOR/web_apps/attractor')
runApp('Dropbox/ATTRACTOR/web_apps/peak_visualizer')
runApp('Dropbox/ATTRACTOR/web_apps/attractor')
shiny::runApp('Dropbox/ATTRACTOR/web_apps/attractor')
setwd("~/Dropbox/ATTRACTOR/web_apps/peak_visualizer")
setwd("~/Dropbox/ATTRACTOR/network")
## Input parameters
## Transcription factor, file name containing targets and ZT value
input.xgmml.file <- "attractor.xgmml"
## Load the package required to read XML files.
library("XML")
library("methods")
## Parse the xgmml file making sure the attribute name spaces are kept
result <- xmlTreeParse(file = input.xgmml.file, addAttributeNamespaces = TRUE)
## Extract root node
rootNode <- xmlRoot(result)
## Extract nodes
node.elements <- xmlElementsByTagName(el = rootNode,name = "node")
## Store nodes info
number.nodes <- length(node.elements)
nodes.names <- vector(mode = "character",length = number.nodes)
nodes.x.pos <- vector(mode = "character",length = number.nodes)
nodes.y.pos <- vector(mode = "character",length = number.nodes)
for(i in 1:number.nodes)
{
current.node <- node.elements[[i]]
nodes.names[i] <- xmlAttrs(current.node)[["label"]]
node.graphic.attrs <- xmlAttrs(xmlElementsByTagName(el = current.node, name = "graphics")[[1]])
nodes.x.pos[i] <- node.graphic.attrs[["x"]]
nodes.y.pos[i] <- node.graphic.attrs[["y"]]
}
nodes.df <- data.frame(names=nodes.names,x.pos=nodes.x.pos,y.pos=nodes.y.pos)
head(nodes.df)
## Add info regarding clusters
peak.zt0 <- read.table(file="clusters/peak_ZT0.txt",as.is=T)[[1]]
peak.zt4 <- read.table(file="clusters/peak_ZT4.txt",as.is=T)[[1]]
peak.zt8 <- read.table(file="clusters/peak_ZT8.txt",as.is=T)[[1]]
peak.zt12 <- read.table(file="clusters/peak_ZT12.txt",as.is=T)[[1]]
peak.zt16 <- read.table(file="clusters/peak_ZT16.txt",as.is=T)[[1]]
peak.zt20 <- read.table(file="clusters/peak_ZT20.txt",as.is=T)[[1]]
cluster.genes <- c(peak.zt0, peak.zt4,peak.zt8,peak.zt12,peak.zt16,peak.zt20)
clusters.names <- paste0("peak", c(rep(0,length(peak.zt0)),
rep(4,length(peak.zt4)),
rep(8,length(peak.zt8)),
rep(12,length(peak.zt12)),
rep(16,length(peak.zt16)),
rep(20,length(peak.zt20))))
names(clusters.names) <- cluster.genes
cluster.classification <- clusters.names[as.vector(nodes.df$names)]
names(cluster.classification) <- NULL
nodes.df <- data.frame(nodes.df,cluster.classification)
write.table(x = nodes.df, file = "attractor_network.tsv",quote = FALSE,sep = "\t",row.names = FALSE)
setwd("~/Dropbox/ATTRACTOR/network/analysis")
## Load library and graph
library(igraph)
## Load ATTRACTOR network and extract gene names
atha.graph <- read.graph(file="../attractor.graphml", format = "graphml")
vertex.names <- V(atha.graph)$name
length(vertex.names)
## Initialise vectors to store topological parameters
atha.neighbors <- vector(mode="character",length=length(vertex.names))
atha.indegree <- vector(mode="numeric",length=length(vertex.names))
atha.outdegree <- vector(mode="numeric",length=length(vertex.names))
atha.trans <- vector(mode="numeric",length=length(vertex.names))
atha.close <- vector(mode="numeric",length=length(vertex.names))
atha.between <- vector(mode="numeric",length=length(vertex.names))
atha.eccent <- vector(mode="numeric",length=length(vertex.names))
## Loop to compute the different topological parameters and the names of the nodes
## connect to curren node (regulators)
for (i in 1:vcount(atha.graph))
{
print(i)
if (length(neighbors(graph = atha.graph, v=vertex.names[i], mode="in")$name) == 0)
{
atha.neighbors[i] <- NA
} else
{
atha.neighbors[i] <- capture.output(cat(neighbors(graph = atha.graph, v=vertex.names[i], mode="in")$name, sep = ","))
}
atha.indegree[i] <- degree(graph = atha.graph, v=vertex.names[i],mode = "in")
atha.outdegree[i] <- degree(graph = atha.graph, v=vertex.names[i],mode = "out")
atha.trans[i] <- transitivity(graph = atha.graph, type = "local", vids=vertex.names[i])
atha.close[i] <- closeness(graph = atha.graph, vids=vertex.names[i], normalized = TRUE)
atha.between[i] <- betweenness(graph = atha.graph, v = vertex.names[i], normalized = TRUE)
atha.eccent[i] <- eccentricity(graph = atha.graph, v = vertex.names[i])
}
## Generate data frame with the topological parameters
node.topological.parameters <- data.frame(vertex.names, atha.neighbors, atha.indegree,
atha.outdegree, atha.trans,
atha.close, atha.between, atha.eccent)
colnames(node.topological.parameters) <- c("names", "regulators", "indegree", "outdegree",
"transitivity", "closeness", "betweeness", "eccentricity")
rownames(node.topological.parameters) <- vertex.names
head(node.topological.parameters)
nrow(node.topological.parameters)
## Add topological parameters to file containing the info of the network used in the web app.
attractor.network <- read.table(file="../attractor_network.tsv",header=TRUE)
head(attractor.network)
nrow(attractor.network)
head(node.topological.parameters[attractor.network$names,])
attractor.network.topological.parameters <- cbind(attractor.network,
node.topological.parameters[as.vector(attractor.network$names),2:ncol(node.topological.parameters)])
head(attractor.network.topological.parameters)
write.table(attractor.network.topological.parameters, file="../attractor_network_topological_parameters.tsv", sep = "\t", quote = FALSE,
row.names = FALSE)
shiny::runApp('~/Dropbox/ATTRACTOR/web_apps/attractor')
setwd("~/Dropbox/ATTRACTOR/web_apps/attractor")
## Load network
network.data <- read.table(file="data/attractor_network_topological_parameters.tsv",header = TRUE,as.is=TRUE)
head(network.data)
## Tranforming coordinates for a better visualization
x.coord <- as.numeric(network.data$y.pos)
y.coord <- as.numeric(network.data$x.pos)
network.data$x.pos <- x.coord
network.data$y.pos <- y.coord
pos.data <- t(matrix(data=c(x.coord,y.coord),ncol=2))
rotation.angle <- pi / 2
rotation.matrix <- matrix(data = c(cos(rotation.angle),sin(rotation.angle),-sin(rotation.angle),cos(rotation.angle)),nrow = 2,ncol = 2)
rotated.pos <- t(rotation.matrix %*% pos.data)
network.data$x.pos <- rotated.pos[,1]
network.data$y.pos <- rotated.pos[,2]
selected.colors <- c("blue4","blue","deepskyblue","gold","firebrick","gray47")
peak.times <- c("peak20","peak0","peak4","peak8","peak12","peak16")
names(selected.colors) <- peak.times
node.colors <- selected.colors[network.data$cluster.classification]
node.colors
which(network.data$names == "AT5G61380")
network.data$cluster.classification[760]
which(network.data$names == "AT5G61380")
(network.data$cluster.classification)[760]
network.data$cluster.classification
## Load network
network.data <- read.table(file="data/attractor_network_topological_parameters.tsv",header = TRUE,as.is=TRUE)
head(network.data)
subset(network.data,names=="AT5G61380")
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
