start.time <- 9
end.time <- 1
if(end.time > start.time)
{
factor.hora <- 180/(end.time - start.time)
max.time <- (start.time + end.time)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time && hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
} else
{
day.length <- (24 - start.time) + end.time
factor.hora <- 180/(day.length)
max.time <- start.time + (day.length)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else if(hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - (hora+24))/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
}
plot(time.points,var.cosw)
start.time <- 10
end.time <- 2
if(end.time > start.time)
{
factor.hora <- 180/(end.time - start.time)
max.time <- (start.time + end.time)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time && hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
} else
{
day.length <- (24 - start.time) + end.time
factor.hora <- 180/(day.length)
max.time <- start.time + (day.length)/2
hora <- 0
time.points <- c()
var.cosw <- c()
increment <- 0.01
i <- 1
while(hora < 24)
{
if(hora >= start.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - hora)/360)
} else if(hora <= end.time)
{
var.cosw[i] <- cos(2*pi*factor.hora*(max.time - (hora+24))/360)
} else
{
var.cosw[i] <- 0
}
time.points[i] <- hora
i <- i + 1
hora <- hora + increment
}
}
plot(time.points,var.cosw)
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/Pedro_de_los_Reyes/arabidopsis_thaliana_clock_network/web_apps/network_visualizer')
runApp('Dropbox/Pedro_de_los_Reyes/arabidopsis_thaliana_clock_network/web_apps/peak_visualizer')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
shiny::runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
runApp('Dropbox/chlamynet/ChlamyNET')
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("ChIPseeker", version = "3.8")
BiocManager::install("ChIPseeker", version = "3.8")
BiocManager::install("ChIPseeker", version = "3.8")
library("ChIPSeeker")
BiocManager::install("ChIPseeker", version = "3.8")
library("ChIPSeeker")
library("ChIPseeker")
options(repos = BiocInstaller::biocinstallRepos())
getOption("repos")
rsconnect::appDependencies()
options(rsconnect.max.bundle.size=3145728000)
rsconnect::appDependencies()
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("BiocGenerics", version = "3.8")
options(repos = BiocInstaller::biocinstallRepos())
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("BiocInstaller", version = "3.8")
options(repos = BiocInstaller::biocinstallRepos())
getOption("repos")
shiny::runApp('Dropbox/ATTRACTOR/web_apps/attractor')
runApp('Dropbox/ATTRACTOR/web_apps/peak_visualizer')
runApp('Dropbox/ATTRACTOR/web_apps/attractor')
shiny::runApp('Dropbox/ATTRACTOR/web_apps/attractor')
shiny::runApp('Dropbox/github_repos/ATTRACTOR/web_apps/peak_visualizer')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor')
??????????????
?
""
??????????????""
?????????""
install.packages("PopGenome")
shiny::runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor')
shiny::runApp('Dropbox/github_repos/BRC1_transcriptional_network')
runApp('Dropbox/github_repos/BRC1_transcriptional_network')
options(repos = BiocInstaller::biocinstallRepos())
shiny::runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor')
shiny::runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor_dev')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor_dev')
data.frame(matrix(nrow=nrow(selected.genes.df), ncol=6))
output.selected.genes.df <- data.frame(matrix(nrow=nrow(selected.genes.df), ncol=6))
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor_dev')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor_dev')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor_dev')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor_dev')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor_dev')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor_dev')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor_dev')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor_dev')
## Load library and graph
library(igraph)
## Load ATTRACTOR network and extract gene names
atha.graph <- read.graph(file="../../attractor.graphml", format = "graphml")
shiny::runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor_dev')
shiny::runApp('Dropbox/github_repos/ATTRACTOR/web_apps/peak_visualizer')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/peak_visualizer')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/peak_visualizer')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/peak_visualizer')
shiny::runApp('Dropbox/github_repos/ATTRACTOR/web_apps/peak_visualizer')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/peak_visualizer')
shiny::runApp('Dropbox/github_repos/ATTRACTOR/web_apps/attractor_dev')
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
target.genes
runApp()
peaks1 <- read.table(file="../peak_visualizer/data/bed_files/PHYA_peaks.narrowPeak")
peaks2 <- read.table(file="../peak_visualizer/data/bed_files/PHYB_peaks.narrowPeak")
real.intersection <- intersectBed(peaks.set1 = peaks1, peaks.set2 = peaks2)
#intersectBed function
intersectBed <- function(peaks.set1, peaks.set2)
{
intersection <- matrix(ncol = 3, nrow=0 )
current.intersection <- matrix(ncol = 3 )
for (i in 1:nrow(peaks.set1))
{
#Set the current peak values of set1
current.chr <- as.numeric(peaks.set1[i,1])
current.start <- peaks.set1[i,2]
current.end <- peaks.set1[i,3]
#Checking if there is intersection between the current peak and any peak of set2
option1 <- nrow(subset(peaks.set2, peaks.set2[,1]==current.chr & peaks.set2[,2]<=current.start & peaks.set2[,3]>=current.start))
option2 <- nrow(subset(peaks.set2, peaks.set2[,1]==current.chr & peaks.set2[,2]<=current.end & peaks.set2[,3]>=current.end))
# print(i)
if(option1+option2 > 0)
{
# print("HIT")
if(option1>0)
{
hit.peak2 <- subset(peaks.set2, peaks.set2[,1]==current.chr & peaks.set2[,2]<=current.start & peaks.set2[,3]>=current.start)
current.intersection[1,1] <- current.chr
current.intersection[1,2] <- current.start
current.intersection[1,3] <- hit.peak2[1,3]
}else
{
hit.peak2 <- subset(peaks.set2, peaks.set2[,1]==current.chr & peaks.set2[,2]<=current.end & peaks.set2[,3]>=current.end)
current.intersection[1,1] <- current.chr
current.intersection[1,2] <- hit.peak2[1,2]
current.intersection[1,3] <- current.end
}
intersection <- rbind(intersection, current.intersection)
}
}
return(intersection)
}
real.intersection <- intersectBed(peaks.set1 = peaks1, peaks.set2 = peaks2)
number.randomisation <- 5
if (nrow(real.intersection) > 0)
{
print("Hay intersección")
random.intersections <- vector(mode = "numeric",length=number.randomisation) #Creating vector
for(j in 1:number.randomisation)
{
print(j)
random.peaks2 <- matrix(nrow=nrow(peaks2),ncol=3) #Matriz con 3 columnas, una para el cromosoma, otra para el comienzo y otra para el final de la región aleatoria.
for(k in 1:nrow(peaks2))
{
current.chr <- peaks2[k,1][[1]] #Chr de la iésima marca real
current.start <- peaks2[k,2] #Start de la iésima marca real
current.end <- peaks2[k,3] #End de la iésima marca real
current.length <- current.end - current.start #Longitud de la iésima marca real
chr.length <- chromosomes.length[current.chr] #Length del actual cromosoma
#Ahora genero los mismos datos para regiones aleatorias
random.start <- floor(runif(n = 1,min = 1,max = chr.length))
random.end <- random.start + current.length
random.peaks2[k,1] <- current.chr
random.peaks2[k,2] <- random.start
random.peaks2[k,3] <- random.end
}
random.intersections[j] <- nrow(intersectBed(peaks.set1 = peaks1, peaks.set2 = random.peaks2 ))
}
p.value <- sum(random.intersections > nrow(real.intersection)) / number.randomisation
if( p.value == 0)
{
p.value <- 1/number.randomisation
}
colnames(real.intersection) <- c("chromosome", "start", "end")
granges.intersection <- makeGRangesFromDataFrame(real.intersection,
keep.extra.columns=FALSE,
ignore.strand=FALSE,
seqinfo=NULL,
seqnames.field="chromosome",
start.field="start",
end.field="end",
starts.in.df.are.0based=FALSE)
peakAnno <- annotatePeak(granges.intersection, tssRegion=c(-2000, 2000),
TxDb=txdb, annoDb="org.At.tair.db")
annot.peaks <- as.data.frame(peakAnno)
target.genes <- subset(annot.peaks, distanceToTSS >= 2000 | distanceToTSS <= -2000)$geneId
# target.genes <- paste(target.genes, collapse = ",")
text.bed <- paste0("The estimated p-value is ", p.value)
} else
{
text.bed <- "No intersection"
}
chromosomes.length <- read.table(file="../peak_visualizer/data/bed_files/atha_chr_lengths.txt",as.is=T)[[1]]
real.intersection <- intersectBed(peaks.set1 = peaks1, peaks.set2 = peaks2)
if (nrow(real.intersection) > 0)
{
print("Hay intersección")
random.intersections <- vector(mode = "numeric",length=number.randomisation) #Creating vector
for(j in 1:number.randomisation)
{
print(j)
random.peaks2 <- matrix(nrow=nrow(peaks2),ncol=3) #Matriz con 3 columnas, una para el cromosoma, otra para el comienzo y otra para el final de la región aleatoria.
for(k in 1:nrow(peaks2))
{
current.chr <- peaks2[k,1][[1]] #Chr de la iésima marca real
current.start <- peaks2[k,2] #Start de la iésima marca real
current.end <- peaks2[k,3] #End de la iésima marca real
current.length <- current.end - current.start #Longitud de la iésima marca real
chr.length <- chromosomes.length[current.chr] #Length del actual cromosoma
#Ahora genero los mismos datos para regiones aleatorias
random.start <- floor(runif(n = 1,min = 1,max = chr.length))
random.end <- random.start + current.length
random.peaks2[k,1] <- current.chr
random.peaks2[k,2] <- random.start
random.peaks2[k,3] <- random.end
}
random.intersections[j] <- nrow(intersectBed(peaks.set1 = peaks1, peaks.set2 = random.peaks2 ))
}
p.value <- sum(random.intersections > nrow(real.intersection)) / number.randomisation
if( p.value == 0)
{
p.value <- 1/number.randomisation
}
colnames(real.intersection) <- c("chromosome", "start", "end")
granges.intersection <- makeGRangesFromDataFrame(real.intersection,
keep.extra.columns=FALSE,
ignore.strand=FALSE,
seqinfo=NULL,
seqnames.field="chromosome",
start.field="start",
end.field="end",
starts.in.df.are.0based=FALSE)
peakAnno <- annotatePeak(granges.intersection, tssRegion=c(-2000, 2000),
TxDb=txdb, annoDb="org.At.tair.db")
annot.peaks <- as.data.frame(peakAnno)
target.genes <- subset(annot.peaks, distanceToTSS >= 2000 | distanceToTSS <= -2000)$geneId
# target.genes <- paste(target.genes, collapse = ",")
text.bed <- paste0("The estimated p-value is ", p.value)
} else
{
text.bed <- "No intersection"
}
txdb <- TxDb.Athaliana.BioMart.plantsmart28
real.intersection <- intersectBed(peaks.set1 = peaks1, peaks.set2 = peaks2)
if (nrow(real.intersection) > 0)
{
print("Hay intersección")
random.intersections <- vector(mode = "numeric",length=number.randomisation) #Creating vector
for(j in 1:number.randomisation)
{
print(j)
random.peaks2 <- matrix(nrow=nrow(peaks2),ncol=3) #Matriz con 3 columnas, una para el cromosoma, otra para el comienzo y otra para el final de la región aleatoria.
for(k in 1:nrow(peaks2))
{
current.chr <- peaks2[k,1][[1]] #Chr de la iésima marca real
current.start <- peaks2[k,2] #Start de la iésima marca real
current.end <- peaks2[k,3] #End de la iésima marca real
current.length <- current.end - current.start #Longitud de la iésima marca real
chr.length <- chromosomes.length[current.chr] #Length del actual cromosoma
#Ahora genero los mismos datos para regiones aleatorias
random.start <- floor(runif(n = 1,min = 1,max = chr.length))
random.end <- random.start + current.length
random.peaks2[k,1] <- current.chr
random.peaks2[k,2] <- random.start
random.peaks2[k,3] <- random.end
}
random.intersections[j] <- nrow(intersectBed(peaks.set1 = peaks1, peaks.set2 = random.peaks2 ))
}
p.value <- sum(random.intersections > nrow(real.intersection)) / number.randomisation
if( p.value == 0)
{
p.value <- 1/number.randomisation
}
colnames(real.intersection) <- c("chromosome", "start", "end")
granges.intersection <- makeGRangesFromDataFrame(real.intersection,
keep.extra.columns=FALSE,
ignore.strand=FALSE,
seqinfo=NULL,
seqnames.field="chromosome",
start.field="start",
end.field="end",
starts.in.df.are.0based=FALSE)
peakAnno <- annotatePeak(granges.intersection, tssRegion=c(-2000, 2000),
TxDb=txdb, annoDb="org.At.tair.db")
annot.peaks <- as.data.frame(peakAnno)
target.genes <- subset(annot.peaks, distanceToTSS >= 2000 | distanceToTSS <= -2000)$geneId
# target.genes <- paste(target.genes, collapse = ",")
text.bed <- paste0("The estimated p-value is ", p.value)
} else
{
text.bed <- "No intersection"
}
text.bed
selected.genes.df <- subset(network.data, names %in% target.genes)
## Load network
#network.data <- read.table(file="data/attractor_network_representation.tsv",header = TRUE,as.is=TRUE,sep="\t",quote = "")
network.data <- read.table(file="data/attractor_network_representation.tsv",header = TRUE,as.is=TRUE,sep="\t",quote = "")
selected.genes.df <- subset(network.data, names %in% target.genes)
selected.genes.df
selected.nodes.colors <- selected.colors[selected.genes.df$peak.zt]
selected.colors <- c("blue4","blue","deepskyblue","gold","firebrick","gray47")
peak.times <- c("peak20","peak0","peak4","peak8","peak12","peak16")
names(selected.colors) <- peak.times
node.colors <- selected.colors[network.data$peak.zt]
names(node.colors) <- NULL
## Extract gene ids
genes <- sort(network.data$name)
selected.genes.df <- subset(network.data, names %in% target.genes)
selected.nodes.colors <- selected.colors[selected.genes.df$peak.zt]
print(selected.genes.df)
print(selected.nodes.colors)
network.representation <- ggplot(network.data, aes(x.pos,y.pos)) +
theme(panel.background = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
axis.title = element_blank(),
axis.text = element_blank(),
axis.ticks.y = element_blank()) +
geom_point(color=node.colors,size=1) +
#geom_point(data = selected.tfs.df, size=8, fill=selected.tfs.df$color,colour="black",pch=21) +
geom_point(data = selected.genes.df,aes(x.pos,y.pos), size=4, fill=selected.nodes.colors,colour="black",pch=21)
output$networkPlot <- renderPlot({
network.representation
},height = 700)
output$outputText <- renderText(expr = text.bed, quoted = FALSE)
runApp()
runApp()
install.packages("shinycssloaders")
runApp()
runApp()
runApp()
runApp()
install.packages("shinyWidgets")
runApp()
runApp()
runApp()
runApp()
library(shiny); runApp('app (copy).R')
runApp('app (copy).R')
runApp('~/Desktop/test')
runApp('app (copy).R')
runApp('app (copy).R')
j
j <- 5
paste("Performing randomisation number", j)
runApp()
runApp()
shiny::runApp()
runApp('~/Dropbox/github_repos/ATTRACTOR/web_apps/network_visualizer')
runApp('~/Dropbox/github_repos/ATTRACTOR/web_apps/network_visualizer')
runApp('~/Dropbox/github_repos/ATTRACTOR/web_apps/peak_visualizer')
runApp('~/Dropbox/github_repos/ATTRACTOR/web_apps/peak_visualizer')
