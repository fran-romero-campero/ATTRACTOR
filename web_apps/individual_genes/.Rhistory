names(agis) <- alias2symbol.table$SYMBOL
agis[is.na(agis)] <- ""
## Color vectors
line.colors <- c("blue","red", "darkgreen","black","#663300","#99003d","#b3b300","#4d0039","#4d2600","#006666","#000066","#003300","#333300","#660066")
area.colors <- c("skyblue","salmon", "lightgreen","lightgrey","#ffcc99","#ff99c2","#ffffb3","#ffe6f9","#ffe6cc","#80ffff","#b3b3ff","#99ff99","#e6e600","#ffb3ff")
## Load chromosome sequences
chr1 <- getSequence(read.fasta(file = "data/athaliana_genome/chr1.fa",seqtype = "AA"))[[1]]
chr2 <- getSequence(read.fasta(file = "data/athaliana_genome/chr2.fa",seqtype = "AA"))[[1]]
chr3 <- getSequence(read.fasta(file = "data/athaliana_genome/chr3.fa",seqtype = "AA"))[[1]]
chr4 <- getSequence(read.fasta(file = "data/athaliana_genome/chr4.fa",seqtype = "AA"))[[1]]
chr5 <- getSequence(read.fasta(file = "data/athaliana_genome/chr5.fa",seqtype = "AA"))[[1]]
## Function to compute the reverse complement
reverse.complement <- function(dna.sequence)
{
return(c2s(comp(rev(s2c(dna.sequence)),forceToLower = FALSE)))
}
## Load Position Weight Matrices
## Open file connection
con <- file("data/jaspar_motifs/pfm_plants_20180911.txt",open = "r")
## Empty list for storing PWM
motifs.pwm <- vector(mode="list",length = 453)
motif.ids <- vector(mode="character",length=453)
motif.names <- vector(mode="character",length=453)
## Load 64 PWM
for(j in 1:453)
{
## First line contains motif id and name
first.line <- readLines(con,1)
motif.ids[j] <- strsplit(first.line,split=" ")[[1]][1]
motif.names[j] <- strsplit(first.line,split=" ")[[1]][2]
## Next four line contians probabilites for each nucleotide
a.row <- as.numeric(strsplit(readLines(con,1),split="( )+")[[1]])
c.row <- as.numeric(strsplit(readLines(con,1),split="( )+")[[1]])
g.row <- as.numeric(strsplit(readLines(con,1),split="( )+")[[1]])
t.row <- as.numeric(strsplit(readLines(con,1),split="( )+")[[1]])
## Construct PWM
motif.pwm <- matrix(nrow = 4,ncol=length(a.row))
motif.pwm[1,] <- a.row
motif.pwm[2,] <- c.row
motif.pwm[3,] <- g.row
motif.pwm[4,] <- t.row
rownames(motif.pwm) <- c("A","C","G","T")
motifs.pwm[[j]] <- prop.table(motif.pwm,2)
}
## Close file connection
close(con)
## Naming list with PWM
names(motifs.pwm) <- motif.names
names(motif.ids) <- motif.names
## Load bigwig files for each transcription factor
bigwig.files <- c("data/bw_files/PHYA.bw",
"data/bw_files/PHYB_FLAG_27_1.bw",
"data/bw_files/PRR5_1.bw",
"data/bw_files/TOC1.bw",
"data/bw_files/CCA1_ZT02.bw",
"data/bw_files/CCA1_ZT14_1.bw",
"data/bw_files/LHY_1.bw",
"data/bw_files/CRY2.bw",
"data/bw_files/FHY1.bw",
"data/bw_files/LUX_ZT10.bw",
"data/bw_files/LUX_ZT12.bw",
"data/bw_files/PIF3.bw",
"data/bw_files/PIF4.bw",
"data/bw_files/PIF5.bw",
"data/bw_files/PRR7.bw",
"data/bw_files/PRR9_1.bw",
"data/bw_files/ELF3_ZT0.bw",
"data/bw_files/ELF3_ZT4.bw",
"data/bw_files/ELF4.bw")
names(bigwig.files) <- c("PHYA ZT00", "PHYB ZT00" ,"PRR5 ZT10", "TOC1 ZT15","CCA1 ZT02",
"CCA1 ZT14","LHY ZT02","CRY2 ZT08","FHY1 ZT04","LUX ZT10",
"LUX ZT12","PIF3 ZT08","PIF4 ZT04","PIF5 ZT04","PRR7 ZT12",
"PRR9 ZT04","ELF3 ZT00", "ELF3 ZT04", "ELF4 ZT10")
## Load bed files for each transcription factor
bed.files <- c("data/bed_files/PHYA_peaks.narrowPeak",
"data/bed_files/PHYB_peaks.narrowPeak",
"data/bed_files/PRR5_1_peaks.narrowPeak",
"data/bed_files/TOC1_1_peaks.narrowPeak",
"data/bed_files/CCA1_ZT02_peaks.narrowPeak",
"data/bed_files/CCA1_ZT14_peaks.narrowPeak",
"data/bed_files/LHY_1_peaks.narrowPeak",
"data/bed_files/CRY2_peaks.narrowPeak",
"data/bed_files/FHY1_peaks.narrowPeak",
"data/bed_files/LUX_ZT10_1_peaks.narrowPeak",
"data/bed_files/LUX_ZT12_1_peaks.narrowPeak",
"data/bed_files/PIF3_peaks.narrowPeak",
"data/bed_files/PIF4_peaks.narrowPeak",
"data/bed_files/PIF5_peaks.narrowPeak",
"data/bed_files/PRR7_peaks.narrowPeak",
"data/bed_files/PRR9_1_peaks.narrowPeak",
"data/bed_files/ELF3_ZT0_1_peaks.narrowPeak",
"data/bed_files/ELF3_ZT4_1_peaks.narrowPeak",
"data/bed_files/ELF4_1_peaks.narrowPeak")
names(bed.files) <- c("PHYA ZT00", "PHYB ZT00" ,"PRR5 ZT10", "TOC1 ZT15","CCA1 ZT02",
"CCA1 ZT14","LHY ZT02","CRY2 ZT08","FHY1 ZT04","LUX ZT10",
"LUX ZT12", "PIF3 ZT08","PIF4 ZT04","PIF5 ZT04","PRR7 ZT12",
"PRR9 ZT04","ELF3 ZT00", "ELF3 ZT04", "ELF4 ZT10")
## TF binding sites colors and symbol shapes
symbol.shapes <- c(17, 18, 19, 15)
symbol.color <- c("blue", "red", "darkgreen", "magenta")
## Colors used to represent repression/activation/neutrality in clock visualizer
repressor.color <- "firebrick1"
activator.color <- "seagreen3"
neutral.color <- "lightgrey"
## Colors to represent gene expression profiles in clock visualizer
selected.colors <- c("blue4","blue","deepskyblue","gold","firebrick","gray47")
peak.times <- c("peak20","peak0","peak4","peak8","peak12","peak16")
names(selected.colors) <- peak.times
## Node colors to represent in the global transcriptional network
node.colors <- selected.colors[network.data$peak.zt]
names(node.colors) <- NULL
## Auxiliary function to determine surrounding ZTs in clock visualizer
zts <- c("ZT00","ZT04","ZT08","ZT12","ZT16","ZT20")
zts.to.consider <- function(zt.point, zts=zts)
{
zts.numeric <- seq(from=0,to=20,by=4)
if(zt.point %in% zts.numeric)
{
return(c(zt.point,zt.point))
} else
{
next.zt <- zts.numeric[which(zts.numeric >= zt.point)[1]]
previous.zt <- zts.numeric[which(zts.numeric >= zt.point)[1] - 1]
return(c(previous.zt, next.zt))
}
}
# Circle and profile parameters for clock visualizer
radius.1 <- 100 #Outer circle radius
height <- 4 ## highest point in ylim for profile plot
#Function for radian conversion
radian.conversion <- function(alpha)
{
rad <- (alpha*pi/180)
return(rad)
}
## Generate coordinates for inner and outer circle in the clock representation for
## clock visualizer
angle <- seq(from=0, to=2*pi, by=0.01)
x.circle.1 <- radius.1*sin(angle)
y.circle.1 <- radius.1*cos(angle)
radius.2 <- radius.1 - radius.1/12
x.circle.2 <- radius.2 * sin(angle)
y.circle.2 <- radius.2 * cos(angle)
## Define vectrors for location of transcription factors in the clock representation
## in clock visualizer
agi.tfs <- c("AT2G46830", "AT1G01060", "AT5G61380", "AT5G24470", "AT5G02810",
"AT2G46790","AT1G09570", "AT2G18790", "AT1G04400", "AT2G37678", "AT3G46640",
"AT1G09530", "AT2G43010", "AT3G59060", "AT2G40080", "AT2G25930")
name.tfs <- c("CCA1", "LHY",  "TOC1", "PRR5", "PRR7", "PRR9", "PHYA", "PHYB",
"CRY2", "FHY1", "LUX", "PIF3", "PIF4", "PIF5", "ELF4", "ELF3")
agi.tfs.zts <- list(c("ZT02","ZT14"),
c("ZT02"),c("ZT15"),c("ZT10"),c("ZT12"),c("ZT04"),c("ZT00"),c("ZT00"),
c("ZT08"),c("ZT04"),c("ZT10","ZT12"),c("ZT08"),c("ZT04"),c("ZT04"),
c("ZT10"),c("ZT00","ZT04"))
## Pasting transcription factors with ZTs
tfs.with.zts <- c()
for (i in 1:length(name.tfs))
{
tfs.with.zts <- c(tfs.with.zts, paste(name.tfs[i], agi.tfs.zts[[i]], sep= "_") )
}
## Determine the number of ZTs points for each transcription factor to represent
## this multiplicity in the clock for clock visualizer
agi.tfs.zts.multiplicity <- sapply(agi.tfs.zts,length)
names(agi.tfs.zts) <- agi.tfs
names(agi.tfs.zts.multiplicity) <- agi.tfs
names(name.tfs) <- agi.tfs
## Extract adjacency matrix
adj.global.matrix <- as.matrix(network.data[,tfs.with.zts])
rownames(adj.global.matrix) <- network.data$names
## Extract expression profiles
mean.expression <- as.matrix(network.data[,zts])
rownames(mean.expression) <- network.data$names
## Computing angles for each transcription factor according to its ZT and
## the muber of transcription factors in that ZT to represent tfs avoiding overlapping.
splitted.tfs.names <- strsplit(tfs.with.zts,split="_")
tfs.angles <- vector(mode="numeric",length=length(tfs.with.zts))
tfs.zts <- vector(mode="numeric",length=length(tfs.with.zts))
for(i in 1:length(splitted.tfs.names))
{
tfs.zts[i] <- substr(x=splitted.tfs.names[i][[1]][2],start = 3,stop=nchar(splitted.tfs.names[i][[1]][2]))
tfs.angles[i] <- radian.conversion(15*as.numeric(tfs.zts[i]))
}
zt.multiplicity <- table(tfs.zts)
## Compute coordinates for each transcription factor setting a radius
## and height to avoid the overlap
radius.to.multiply <- vector(mode="numeric",length=length(splitted.tfs.names))
height.to.multiply <- vector(mode="numeric",length=length(splitted.tfs.names))
node.labels <- vector(mode="numeric",length=length(splitted.tfs.names))
for(i in 1:length(splitted.tfs.names))
{
node.labels[i] <- splitted.tfs.names[i][[1]][1]
current.zt <- substr(x=splitted.tfs.names[i][[1]][2],start=3,stop=nchar(splitted.tfs.names[i][[1]][2]))
current.multiplicity <- zt.multiplicity[current.zt]
radius.to.multiply[i] <- (1 - (0.16*current.multiplicity))*radius.1
height.to.multiply[i] <- (1 - (0.1*current.multiplicity))*height
zt.multiplicity[current.zt] <- zt.multiplicity[current.zt] - 1
}
get.first <- function(my.vector)
{
return(my.vector[[1]])
}
# names(height.to.multiply) <- tfs.names
names(height.to.multiply) <- tfs.with.zts
## Set the x.y coordinates for the positions
tfs.x <- radius.to.multiply * sin(tfs.angles)
tfs.y <- radius.to.multiply * cos(tfs.angles)
## Generating a positions matrix
matrix.pos <- matrix(data = c(tfs.x, tfs.y), nrow = length(tfs.x), ncol = 2)
## Function to generate output table
create.output.table <- function(input.gene.df,alias,tfs.names)
{
output.selected.genes.df <- data.frame(matrix(nrow=nrow(input.gene.df), ncol=6))
colnames(output.selected.genes.df) <- c("AGI ID", "Gene Name", "Gene Description", "Regulators","Expression Peak Time","Expression Trough Time")
output.selected.genes.df$`Gene Description` <- input.gene.df$description
for(i in 1:nrow(output.selected.genes.df))
{
tair.link <- paste0("https://www.arabidopsis.org/servlets/TairObject?type=locus&name=",input.gene.df[i,1])
output.selected.genes.df[i,1] <- paste(c("<a href=\"",
tair.link,
"\" target=\"_blank\">",
input.gene.df[i,1], "</a>"),
collapse="")
output.selected.genes.df[i,2] <- alias[input.gene.df[i,1]]
output.selected.genes.df[i,4] <- paste(tfs.names[which(input.gene.df[i,tfs.names] == 1)],collapse=", ")
output.selected.genes.df[i,5] <-paste0("ZT",substr(input.gene.df[i,"peak.zt"],start=5,stop=nchar(input.gene.df[i,"peak.zt"])))
output.selected.genes.df[i,6] <-paste0("ZT",substr(input.gene.df[i,"trough.zt"],start=7,stop=nchar(input.gene.df[i,"trough.zt"])))
}
return(output.selected.genes.df)
}
## Function to generate output table to download
create.downloadable.output.table <- function(input.gene.df,alias,tfs.names)
{
output.selected.genes.df <- data.frame(matrix(nrow=nrow(input.gene.df), ncol=6))
colnames(output.selected.genes.df) <- c("AGI ID", "Gene Name", "Gene Description", "Regulators","Expression Peak Time","Expression Trough Time")
output.selected.genes.df$`Gene Description` <- input.gene.df$description
for(i in 1:nrow(output.selected.genes.df))
{
output.selected.genes.df[i,1] <- input.gene.df[i,1]
output.selected.genes.df[i,2] <- alias[input.gene.df[i,1]]
output.selected.genes.df[i,4] <- paste(tfs.names[which(input.gene.df[i,tfs.names] == 1)],collapse=", ")
output.selected.genes.df[i,5] <-paste0("ZT",substr(input.gene.df[i,"peak.zt"],start=5,stop=nchar(input.gene.df[i,"peak.zt"])))
output.selected.genes.df[i,6] <-paste0("ZT",substr(input.gene.df[i,"trough.zt"],start=7,stop=nchar(input.gene.df[i,"trough.zt"])))
}
return(output.selected.genes.df)
}
## Auxiliary function to compute enrichments for GO table
compute.enrichments <- function(gene.ratios, bg.ratios)
{
gene.ratios.eval <- sapply(parse(text=gene.ratios),FUN = eval)
bg.ratios.eval <- sapply(parse(text=bg.ratios),FUN = eval)
enrichments <- round(x=gene.ratios.eval/bg.ratios.eval,digits = 2)
enrichments.text <- paste(enrichments, " (", gene.ratios, "; ", bg.ratios, ")",sep="")
return(enrichments.text)
}
#GO links and tair link functions
go.link <- function(go.term)
{
link <- paste0("http://amigo.geneontology.org/amigo/term/", go.term)
complete.link <- paste(c("<a href=\"",
link,
"\" target=\"_blank\">",
go.term, "</a>"),
collapse = "")
return(complete.link)
}
gene.link.function <- function(gene.name)
{
tair.link <- paste(c("https://www.arabidopsis.org/servlets/TairObject?name=",
gene.name,
"&type=locus"),collapse="")
gene.link <- paste(c("<a href=\"",
tair.link,
"\" target=\"_blank\">",
gene.name, "</a>"),
collapse="")
return(gene.link)
}
## KEGG pathway link
kegg.pathway.link <- function(kegg.pathway)
{
link <- paste0("https://www.genome.jp/kegg-bin/show_pathway?",kegg.pathway)
complete.link <- paste(c("<a href=\"",
link,
"\" target=\"_blank\">",
kegg.pathway, "</a>"),
collapse = "")
return(complete.link)
}
## KEGG module link
kegg.module.link <- function(kegg.module)
{
link <- paste0("https://www.genome.jp/kegg-bin/show_module?",kegg.module)
complete.link <- paste(c("<a href=\"",
link,
"\" target=\"_blank\">",
kegg.module, "</a>"),
collapse = "")
return(complete.link)
}
## TFBS jaspar link
tfbs.link <- function(motif.id)
{
link <- paste0("http://jaspar.genereg.net/matrix/",motif.id)
complete.link <- paste(c("<a href=\"",
link,
"\" target=\"_blank\">",
motif.id, "</a>"),
collapse = "")
return(complete.link)
}
## Red gradient for animation
red.gradient <- colorRampPalette(c("red", "white"))
current.red.gradient <- c(red.gradient(5),rep("#FFFFFF",15))
## Sanity checks
validate(
need(input$selected.multiple.tfs, "Please select a set of transcription factors")
)
## Determine targets of selected TFs
selected.tfs.with.zts <- str_replace(string = input$selected.multiple.tfs,pattern = " ",replacement = "_")
selected.only.tfs <- sapply(X = strsplit(x = input$selected.multiple.tfs,split = " "), FUN = get.first)
selected.tfs.adj <- (network.data[,selected.tfs.with.zts] != 0)
if(length(selected.tfs.with.zts) > 1)
{
gene.selection <- rowSums(selected.tfs.adj) == length(selected.tfs.with.zts)
} else if (length(selected.tfs.with.zts) == 1)
{
gene.selection <- as.vector(selected.tfs.adj)
}
## Determine targets with the specified expression profile
selected.genes.df <- network.data[gene.selection,]
if(input$peak != "any" && input$trough != "any")
{
selected.genes.df <- subset(selected.genes.df, (peak.zt == input$peak & trough.zt == input$trough))
} else if(input$peak == "any" && input$trough != "any")
{
selected.genes.df <- subset(selected.genes.df, trough.zt == input$trough)
} else if(input$peak != "any" && input$trough == "any")
{
selected.genes.df <- subset(selected.genes.df, peak.zt == input$peak)
}
## Set the background to perform TFBS enrichment analysis depending on the user selection
if (input$tfbs_background == "allgenome")
{
tfbs.universe <- 33323
} else
{
tfbs.universe <- 5778
}
file.precomputed <- paste0(c("precomputed_",input$up_promoter,"_",
input$down_promoter, "_",
input$score, "_",tfbs.universe,".tsv"),collapse="")
## Load file with precomputed results (background) and compute m and n
precomputed.result <- read.table(file=paste0("data/precomputed_results_tfbs/",file.precomputed),header = T)
m <- colSums(precomputed.result > 0)
n <- nrow(precomputed.result) - m
## Compute selection size (k) and number of ocurrences (x).
# target.genes <- read.table(file = "peak_ZT0_trough_ZT12.txt",as.is = T)[[1]]
target.genes <- intersect(rownames(precomputed.result),selected.genes.df$names)
k <- length(target.genes)
x <- colSums(precomputed.result[target.genes,] > 0)
## Compute p-values for enrichment according to a hypergeometric distribution
p.values <- vector(mode="numeric", length=length(x))
names(p.values) <- colnames(precomputed.result)
for(i in 1:length(x))
{
p.values[i] <- phyper(q = x[i] - 1, m = m[i], n = n[i], k = k, lower.tail = F)
}
which(p.values < input$motif_significance)
p.values[which(p.values < input$motif_significance)]
## Adjust p-values using Benjamini Hochberg
q.values <- p.adjust(p = p.values,method = "BH")
which(q.values < input$motif_significance)
q.values[which(q.values < input$motif_significance)]
## Compute enrichments
enrichments <- (x / k) / (m / nrow(precomputed.result))
## Final motifs, pvalues, qvalues and enrichments
input <- list(motif_significance = 0.05, enrichment_threshold = 2 )
sig.enrich.motifs <- names(which(q.values < input$motif_significance & enrichments > input$enrichment_threshold))
sig.enrich.motifs
sig.enrich.motifs <- names(which(q.values < input$motif_significance & enrichments > input$enrichment_threshold))
sig.enrich.ids <- motif.ids[sig.enrich.motifs]
final.q.values <- q.values[which(q.values < input$motif_significance & enrichments > input$enrichment_threshold)]
final.p.values <- p.values[which(q.values < input$motif_significance & enrichments > input$enrichment_threshold)]
final.enrichments <- enrichments[which(q.values < input$motif_significance & enrichments > input$enrichment_threshold)]
## Determine genes for each motif
genes.with.motif <- vector("list", length(sig.enrich.motifs))
for (i in 1:length(sig.enrich.motifs))
{
rows.with.motif <- which(precomputed.result[,sig.enrich.motifs[i]] != 0)
all.genes.with.motif <- rownames(precomputed.result)[rows.with.motif]
genes.with.motif[i] <- paste(... = intersect(all.genes.with.motif,target.genes), collapse = ",")
}
## Determine genes for each motif
genes.with.motif <- vector("list", length(sig.enrich.motifs))
for (i in 1:length(sig.enrich.motifs))
{
print[i]
rows.with.motif <- which(precomputed.result[,sig.enrich.motifs[i]] != 0)
all.genes.with.motif <- rownames(precomputed.result)[rows.with.motif]
genes.with.motif[i] <- paste(... = intersect(all.genes.with.motif,target.genes), collapse = ",")
}
## Determine genes for each motif
genes.with.motif <- vector("list", length(sig.enrich.motifs))
for (i in 1:length(sig.enrich.motifs))
{
print(i)
rows.with.motif <- which(precomputed.result[,sig.enrich.motifs[i]] != 0)
all.genes.with.motif <- rownames(precomputed.result)[rows.with.motif]
genes.with.motif[i] <- paste(... = intersect(all.genes.with.motif,target.genes), collapse = ",")
}
## Motifs logos
motifs.images <- paste0("motifs_images/",sig.enrich.motifs)
for (i in 1:length(motifs.images))
{
motifs.images[i] <- paste0("<img src='",motifs.images[i],".png', align = 'center', width = 100>")
}
## Store data
tfbs.result.table <- data.frame(sig.enrich.motifs, sig.enrich.ids, motifs.images, final.p.values, final.q.values, final.enrichments, genes.with.motif)
head(tfbs.result.table)
tfbs.result.table[1:6,1:2]
tfbs.result.table[1:6,1:5]
tfbs.result.table[1:6,1:7]
genes.with.motif
final.enrichments
final.q.values
sig.enrich.ids
final.q.values
sig.enrich.motifs
final.p.values
final.enrichments
sig.enrich.motifs
## Determine genes for each motif
genes.with.motif <- vector("list", length(sig.enrich.motifs))
genes.with.motif
## Determine genes for each motif
genes.with.motif <- vector(length = length(sig.enrich.motifs))
for (i in 1:length(sig.enrich.motifs))
{
print(i)
rows.with.motif <- which(precomputed.result[,sig.enrich.motifs[i]] != 0)
all.genes.with.motif <- rownames(precomputed.result)[rows.with.motif]
genes.with.motif[i] <- paste(... = intersect(all.genes.with.motif,target.genes), collapse = ",")
}
genes.with.motif
## Store data
tfbs.result.table <- data.frame(sig.enrich.motifs, sig.enrich.ids, motifs.images, final.p.values, final.q.values, final.enrichments, genes.with.motif)
colnames(tfbs.result.table) <- c("DNA motifs", "Motif ID", "DNA logo", "P-values", "Q-values", "Enrichments", "Genes")
tfbs.result.table
runApp()
shiny::runApp()
library(org.Otauri.eg.db)
keytypes(org.Otauri.eg())
keytypes(org.Otauri.eg.db)
tf.p.values <- function(targets.tf,
brc1.dependent = 947,
brc1.bound = 4338,
brc1.direct.targets = 1954,
brc1.bona.fide = 108,
targets.in.brc1.sets)
{
## BRC1 dep
N <- 33601
m <- targets.tf
n <- N - m
k <- brc1.dependent
x <- targets.in.brc1.sets[1]
percent.brc1.dep <- x/k
pvalue.brc1.dep <- phyper(q = x - 1 , m = m, n = n , k = k, lower.tail = F)
exp.brc1.dep <- phyper(q = x - 1 , m = m, n = n , k = k, lower.tail = F,log.p = T)/log(10)
## BRC1 bound
k <- brc1.bound     # BRC1 bound
x <- targets.in.brc1.sets[2]
percent.brc1.bound <- x/k
pvalue.brc1.bound <- phyper(q = x - 1 , m = m, n = n , k = k, lower.tail = F)
exp.brc1.bound <- phyper(q = x - 1 , m = m, n = n , k = k, lower.tail = F,log.p = T)/log(10)
## BRC1 direct targets
k <- brc1.direct.targets     # BRC1 direct targets
x <- targets.in.brc1.sets[3]
percent.brc1.direct.targets <- x/k
pvalue.brc1.direct.targets <- phyper(q = x - 1 , m = m, n = n , k = k, lower.tail = F)
exp.brc1.direct.targets <- phyper(q = x - 1 , m = m, n = n , k = k, lower.tail = F,log.p = T)/log(10)
## BRC1 targets bona fide
k <- brc1.bona.fide    # BRC1 bona fide targets
x <- targets.in.brc1.sets[4]
percent.brc1.bona.fide <- x/k
pvalue.brc1.bona.fide <- phyper(q = x - 1 , m = m, n = n , k = k, lower.tail = F)
exp.brc1.bona.fide <- phyper(q = x - 1 , m = m, n = n , k = k, lower.tail = F,log.p = T)/log(10)
return(list(
percent.brc1.dep = percent.brc1.dep,
pvalue.brc1.dep = pvalue.brc1.dep,
exp.brc1.dep = exp.brc1.dep,
percent.brc1.bound = percent.brc1.bound,
pvalue.brc1.bound = pvalue.brc1.bound,
exp.brc1.bound = exp.brc1.bound,
percent.brc1.direct.targets = percent.brc1.direct.targets,
pvalue.brc1.direct.targets = pvalue.brc1.direct.targets,
exp.brc1.direct.targets = exp.brc1.direct.targets,
percent.brc1.bona.fide = percent.brc1.bona.fide,
pvalue.brc1.bona.fide = pvalue.brc1.bona.fide,
exp.brc1.bona.fide = exp.brc1.bona.fide
))
}
tf.p.values(targets.tf = 11298,targets.in.brc1.sets = c(558, 3077,1470, 91))
tf.p.values(targets.tf = 11298,targets.in.brc1.sets = c(558, 3077,1470, 91))
## ABF3
tf.p.values(targets.tf = 12376,targets.in.brc1.sets = c(587, 3213,1507, 91))
## GBF3
tf.p.values(targets.tf = 15619,targets.in.brc1.sets = c(674, 3446, 1626, 96))
## ABI5
tf.p.values(targets.tf = 4188,targets.in.brc1.sets = c(244, 1329, 718, 56))
## ATHB-40
tf.p.values(targets.tf = 14742,targets.in.brc1.sets = c(539, 2373, 1140, 70))
