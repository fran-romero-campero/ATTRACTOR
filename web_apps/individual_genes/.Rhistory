I
shiny::runApp('Desktop/test')
runApp('Desktop/test')
install.packages("blogdown")
shiny::runApp('Desktop/test')
runApp('Desktop/test')
a <- factor(c("character", "in", "the", "streets"))
b <- factor(c("integer", "in", "the", 'sheets'))
c(a, b)
c("character", "in", "the", "streets")
factor(c("character", "in", "the", "streets"))
b
c(a, b)
shiny::runApp('Dropbox/github_repos/ATTRACTOR/web_apps/individual_genes')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/individual_genes')
runApp('Dropbox/github_repos/ATTRACTOR/web_apps/individual_genes')
shiny::runApp('Dropbox/github_repos/ATTRACTOR/web_apps/individual_genes')
input <- list(selected.multiple.tfs= c("LUX ZT10", "LUX ZT12"), peak = "any", trough = "any", up_promoter = 1000, down_promoter = 0, score = 95, tfbs_background = "onlynet", motif_significance=0.05, enrichment_threshold=2)
setwd("~/Dropbox/github_repos/ATTRACTOR/web_apps/individual_genes")
runApp()
# Load neccesary libraries
library(shiny)
library(ChIPpeakAnno)
library(rtracklayer)
library(TxDb.Athaliana.BioMart.plantsmart28)
library(Biostrings)
library(seqinr)
library(org.At.tair.db)
library(igraph)
library(ggplot2)
library(stringr)
library(clusterProfiler)
library(pathview)
library(shinycssloaders)
library(shinyWidgets)
library(shinyjs)
library(SuperExactTest)
library(VennDiagram)
##Load the network data
network.data <- read.table(file="data/attractor_network_representation.tsv",header = TRUE,as.is=TRUE,sep="\t",quote = "")
rownames(network.data) <- network.data$names
## Tranforming coordinates for a better visualization
x.coord <- as.numeric(network.data$y.pos)
y.coord <- as.numeric(network.data$x.pos)
network.data$x.pos <- x.coord
network.data$y.pos <- y.coord
pos.data <- t(matrix(data=c(x.coord,y.coord),ncol=2))
rotation.angle <- -pi/2
rotation.matrix <- matrix(data = c(cos(rotation.angle),sin(rotation.angle),-sin(rotation.angle),cos(rotation.angle)),nrow = 2,ncol = 2)
rotated.pos <- t(rotation.matrix %*% pos.data)
network.data$x.pos <- rotated.pos[,1]
network.data$y.pos <- rotated.pos[,2]
## Load normalized gene expression data for animation
norm.data <- read.table(file = "data/normalized_gene_expression.txt",header = T,sep = "\t")
## Transcription factors AGI ids and names
tfs.names <- c("CCA1","LHY", "TOC1", "PRR5", "PRR7", "PRR9", "PHYA","PHYB",
"CRY2","FHY1","LUX","PIF3","PIF4","PIF5","ELF4","ELF3")
tf.ids <- c("AT2G46830", "AT1G01060", "AT5G61380", "AT5G24470", "AT5G02810", "AT2G46790",
"AT1G09570", "AT2G18790", "AT1G04400", "AT2G37678", "AT3G46640", "AT1G09530",
"AT2G43010", "AT3G59060", "AT2G40080", "AT2G25930")
names(tf.ids) <- tfs.names
## Extract gene ids
genes <- sort(network.data$name)
## Load and extract Arabidopsis thaliana annotation regarding genes, exons and cds
txdb <- TxDb.Athaliana.BioMart.plantsmart28
genes.data <- subset(genes(txdb), seqnames %in% c("1","2","3","4","5")) ## only nuclear genes are considered
genes.data <- as.data.frame(genes.data)
exons.data <- as.data.frame(exons(txdb))
cds.data <- as.data.frame(cds(txdb))
## Load all and circadian genes
alias2symbol.table <- AnnotationDbi::select(org.At.tair.db,
keys=keys(org.At.tair.db, keytype="ENTREZID"),
columns=c("SYMBOL", "TAIR"), keytype="ENTREZID")
ath.universe <- alias2symbol.table$TAIR
alias2symbol.table <- subset(alias2symbol.table, TAIR %in% genes)
alias <- alias2symbol.table$SYMBOL
names(alias) <- alias2symbol.table$TAIR
alias[is.na(alias)] <- ""
genes.selectize <- paste(names(alias), alias, sep=" - ")
## Setting conversion between alias and agis
agis <-alias2symbol.table$TAIR
names(agis) <- alias2symbol.table$SYMBOL
agis[is.na(agis)] <- ""
## Color vectors
line.colors <- c("blue","red", "darkgreen","black","#663300","#99003d","#b3b300","#4d0039","#4d2600","#006666","#000066","#003300","#333300","#660066")
area.colors <- c("skyblue","salmon", "lightgreen","lightgrey","#ffcc99","#ff99c2","#ffffb3","#ffe6f9","#ffe6cc","#80ffff","#b3b3ff","#99ff99","#e6e600","#ffb3ff")
## Load chromosome sequences
chr1 <- getSequence(read.fasta(file = "data/athaliana_genome/chr1.fa",seqtype = "AA"))[[1]]
chr2 <- getSequence(read.fasta(file = "data/athaliana_genome/chr2.fa",seqtype = "AA"))[[1]]
chr3 <- getSequence(read.fasta(file = "data/athaliana_genome/chr3.fa",seqtype = "AA"))[[1]]
chr4 <- getSequence(read.fasta(file = "data/athaliana_genome/chr4.fa",seqtype = "AA"))[[1]]
chr5 <- getSequence(read.fasta(file = "data/athaliana_genome/chr5.fa",seqtype = "AA"))[[1]]
## Function to compute the reverse complement
reverse.complement <- function(dna.sequence)
{
return(c2s(comp(rev(s2c(dna.sequence)),forceToLower = FALSE)))
}
## Load Position Weight Matrices
## Open file connection
con <- file("data/jaspar_motifs/pfm_plants_20180911.txt",open = "r")
## Empty list for storing PWM
motifs.pwm <- vector(mode="list",length = 453)
motif.ids <- vector(mode="character",length=453)
motif.names <- vector(mode="character",length=453)
## Load 64 PWM
for(j in 1:453)
{
## First line contains motif id and name
first.line <- readLines(con,1)
motif.ids[j] <- strsplit(first.line,split=" ")[[1]][1]
motif.names[j] <- strsplit(first.line,split=" ")[[1]][2]
## Next four line contians probabilites for each nucleotide
a.row <- as.numeric(strsplit(readLines(con,1),split="( )+")[[1]])
c.row <- as.numeric(strsplit(readLines(con,1),split="( )+")[[1]])
g.row <- as.numeric(strsplit(readLines(con,1),split="( )+")[[1]])
t.row <- as.numeric(strsplit(readLines(con,1),split="( )+")[[1]])
## Construct PWM
motif.pwm <- matrix(nrow = 4,ncol=length(a.row))
motif.pwm[1,] <- a.row
motif.pwm[2,] <- c.row
motif.pwm[3,] <- g.row
motif.pwm[4,] <- t.row
rownames(motif.pwm) <- c("A","C","G","T")
motifs.pwm[[j]] <- prop.table(motif.pwm,2)
}
## Close file connection
close(con)
## Naming list with PWM
names(motifs.pwm) <- motif.names
names(motif.ids) <- motif.names
## Load bigwig files for each transcription factor
bigwig.files <- c("data/bw_files/PHYA.bw",
"data/bw_files/PHYB_FLAG_27_1.bw",
"data/bw_files/PRR5_1.bw",
"data/bw_files/TOC1.bw",
"data/bw_files/CCA1_ZT02.bw",
"data/bw_files/CCA1_ZT14_1.bw",
"data/bw_files/LHY_1.bw",
"data/bw_files/CRY2.bw",
"data/bw_files/FHY1.bw",
"data/bw_files/LUX_ZT10.bw",
"data/bw_files/LUX_ZT12.bw",
"data/bw_files/PIF3.bw",
"data/bw_files/PIF4.bw",
"data/bw_files/PIF5.bw",
"data/bw_files/PRR7.bw",
"data/bw_files/PRR9_1.bw",
"data/bw_files/ELF3_ZT0.bw",
"data/bw_files/ELF3_ZT4.bw",
"data/bw_files/ELF4.bw")
names(bigwig.files) <- c("PHYA ZT00", "PHYB ZT00" ,"PRR5 ZT10", "TOC1 ZT15","CCA1 ZT02",
"CCA1 ZT14","LHY ZT02","CRY2 ZT08","FHY1 ZT04","LUX ZT10",
"LUX ZT12","PIF3 ZT08","PIF4 ZT04","PIF5 ZT04","PRR7 ZT12",
"PRR9 ZT04","ELF3 ZT00", "ELF3 ZT04", "ELF4 ZT10")
## Load bed files for each transcription factor
bed.files <- c("data/bed_files/PHYA_peaks.narrowPeak",
"data/bed_files/PHYB_peaks.narrowPeak",
"data/bed_files/PRR5_1_peaks.narrowPeak",
"data/bed_files/TOC1_1_peaks.narrowPeak",
"data/bed_files/CCA1_ZT02_peaks.narrowPeak",
"data/bed_files/CCA1_ZT14_peaks.narrowPeak",
"data/bed_files/LHY_1_peaks.narrowPeak",
"data/bed_files/CRY2_peaks.narrowPeak",
"data/bed_files/FHY1_peaks.narrowPeak",
"data/bed_files/LUX_ZT10_1_peaks.narrowPeak",
"data/bed_files/LUX_ZT12_1_peaks.narrowPeak",
"data/bed_files/PIF3_peaks.narrowPeak",
"data/bed_files/PIF4_peaks.narrowPeak",
"data/bed_files/PIF5_peaks.narrowPeak",
"data/bed_files/PRR7_peaks.narrowPeak",
"data/bed_files/PRR9_1_peaks.narrowPeak",
"data/bed_files/ELF3_ZT0_1_peaks.narrowPeak",
"data/bed_files/ELF3_ZT4_1_peaks.narrowPeak",
"data/bed_files/ELF4_1_peaks.narrowPeak")
names(bed.files) <- c("PHYA ZT00", "PHYB ZT00" ,"PRR5 ZT10", "TOC1 ZT15","CCA1 ZT02",
"CCA1 ZT14","LHY ZT02","CRY2 ZT08","FHY1 ZT04","LUX ZT10",
"LUX ZT12", "PIF3 ZT08","PIF4 ZT04","PIF5 ZT04","PRR7 ZT12",
"PRR9 ZT04","ELF3 ZT00", "ELF3 ZT04", "ELF4 ZT10")
## TF binding sites colors and symbol shapes
symbol.shapes <- c(17, 18, 19, 15)
symbol.color <- c("blue", "red", "darkgreen", "magenta")
## Colors used to represent repression/activation/neutrality in clock visualizer
repressor.color <- "firebrick1"
activator.color <- "seagreen3"
neutral.color <- "lightgrey"
## Colors to represent gene expression profiles in clock visualizer
selected.colors <- c("blue4","blue","deepskyblue","gold","firebrick","gray47")
peak.times <- c("peak20","peak0","peak4","peak8","peak12","peak16")
names(selected.colors) <- peak.times
## Node colors to represent in the global transcriptional network
node.colors <- selected.colors[network.data$peak.zt]
names(node.colors) <- NULL
## Auxiliary function to determine surrounding ZTs in clock visualizer
zts <- c("ZT00","ZT04","ZT08","ZT12","ZT16","ZT20")
zts.to.consider <- function(zt.point, zts=zts)
{
zts.numeric <- seq(from=0,to=20,by=4)
if(zt.point %in% zts.numeric)
{
return(c(zt.point,zt.point))
} else
{
next.zt <- zts.numeric[which(zts.numeric >= zt.point)[1]]
previous.zt <- zts.numeric[which(zts.numeric >= zt.point)[1] - 1]
return(c(previous.zt, next.zt))
}
}
# Circle and profile parameters for clock visualizer
radius.1 <- 100 #Outer circle radius
height <- 4 ## highest point in ylim for profile plot
#Function for radian conversion
radian.conversion <- function(alpha)
{
rad <- (alpha*pi/180)
return(rad)
}
## Generate coordinates for inner and outer circle in the clock representation for
## clock visualizer
angle <- seq(from=0, to=2*pi, by=0.01)
x.circle.1 <- radius.1*sin(angle)
y.circle.1 <- radius.1*cos(angle)
radius.2 <- radius.1 - radius.1/12
x.circle.2 <- radius.2 * sin(angle)
y.circle.2 <- radius.2 * cos(angle)
## Define vectrors for location of transcription factors in the clock representation
## in clock visualizer
agi.tfs <- c("AT2G46830", "AT1G01060", "AT5G61380", "AT5G24470", "AT5G02810",
"AT2G46790","AT1G09570", "AT2G18790", "AT1G04400", "AT2G37678", "AT3G46640",
"AT1G09530", "AT2G43010", "AT3G59060", "AT2G40080", "AT2G25930")
name.tfs <- c("CCA1", "LHY",  "TOC1", "PRR5", "PRR7", "PRR9", "PHYA", "PHYB",
"CRY2", "FHY1", "LUX", "PIF3", "PIF4", "PIF5", "ELF4", "ELF3")
agi.tfs.zts <- list(c("ZT02","ZT14"),
c("ZT02"),c("ZT15"),c("ZT10"),c("ZT12"),c("ZT04"),c("ZT00"),c("ZT00"),
c("ZT08"),c("ZT04"),c("ZT10","ZT12"),c("ZT08"),c("ZT04"),c("ZT04"),
c("ZT10"),c("ZT00","ZT04"))
## Pasting transcription factors with ZTs
tfs.with.zts <- c()
for (i in 1:length(name.tfs))
{
tfs.with.zts <- c(tfs.with.zts, paste(name.tfs[i], agi.tfs.zts[[i]], sep= "_") )
}
## Determine the number of ZTs points for each transcription factor to represent
## this multiplicity in the clock for clock visualizer
agi.tfs.zts.multiplicity <- sapply(agi.tfs.zts,length)
names(agi.tfs.zts) <- agi.tfs
names(agi.tfs.zts.multiplicity) <- agi.tfs
names(name.tfs) <- agi.tfs
## Extract adjacency matrix
adj.global.matrix <- as.matrix(network.data[,tfs.with.zts])
rownames(adj.global.matrix) <- network.data$names
## Extract expression profiles
mean.expression <- as.matrix(network.data[,zts])
rownames(mean.expression) <- network.data$names
## Computing angles for each transcription factor according to its ZT and
## the muber of transcription factors in that ZT to represent tfs avoiding overlapping.
splitted.tfs.names <- strsplit(tfs.with.zts,split="_")
tfs.angles <- vector(mode="numeric",length=length(tfs.with.zts))
tfs.zts <- vector(mode="numeric",length=length(tfs.with.zts))
for(i in 1:length(splitted.tfs.names))
{
tfs.zts[i] <- substr(x=splitted.tfs.names[i][[1]][2],start = 3,stop=nchar(splitted.tfs.names[i][[1]][2]))
tfs.angles[i] <- radian.conversion(15*as.numeric(tfs.zts[i]))
}
zt.multiplicity <- table(tfs.zts)
## Compute coordinates for each transcription factor setting a radius
## and height to avoid the overlap
radius.to.multiply <- vector(mode="numeric",length=length(splitted.tfs.names))
height.to.multiply <- vector(mode="numeric",length=length(splitted.tfs.names))
node.labels <- vector(mode="numeric",length=length(splitted.tfs.names))
for(i in 1:length(splitted.tfs.names))
{
node.labels[i] <- splitted.tfs.names[i][[1]][1]
current.zt <- substr(x=splitted.tfs.names[i][[1]][2],start=3,stop=nchar(splitted.tfs.names[i][[1]][2]))
current.multiplicity <- zt.multiplicity[current.zt]
radius.to.multiply[i] <- (1 - (0.16*current.multiplicity))*radius.1
height.to.multiply[i] <- (1 - (0.1*current.multiplicity))*height
zt.multiplicity[current.zt] <- zt.multiplicity[current.zt] - 1
}
get.first <- function(my.vector)
{
return(my.vector[[1]])
}
# names(height.to.multiply) <- tfs.names
names(height.to.multiply) <- tfs.with.zts
## Set the x.y coordinates for the positions
tfs.x <- radius.to.multiply * sin(tfs.angles)
tfs.y <- radius.to.multiply * cos(tfs.angles)
## Generating a positions matrix
matrix.pos <- matrix(data = c(tfs.x, tfs.y), nrow = length(tfs.x), ncol = 2)
## Function to generate output table
create.output.table <- function(input.gene.df,alias,tfs.names)
{
output.selected.genes.df <- data.frame(matrix(nrow=nrow(input.gene.df), ncol=6))
colnames(output.selected.genes.df) <- c("AGI ID", "Gene Name", "Gene Description", "Regulators","Expression Peak Time","Expression Trough Time")
output.selected.genes.df$`Gene Description` <- input.gene.df$description
for(i in 1:nrow(output.selected.genes.df))
{
tair.link <- paste0("https://www.arabidopsis.org/servlets/TairObject?type=locus&name=",input.gene.df[i,1])
output.selected.genes.df[i,1] <- paste(c("<a href=\"",
tair.link,
"\" target=\"_blank\">",
input.gene.df[i,1], "</a>"),
collapse="")
output.selected.genes.df[i,2] <- alias[input.gene.df[i,1]]
output.selected.genes.df[i,4] <- paste(tfs.names[which(input.gene.df[i,tfs.names] == 1)],collapse=", ")
output.selected.genes.df[i,5] <-paste0("ZT",substr(input.gene.df[i,"peak.zt"],start=5,stop=nchar(input.gene.df[i,"peak.zt"])))
output.selected.genes.df[i,6] <-paste0("ZT",substr(input.gene.df[i,"trough.zt"],start=7,stop=nchar(input.gene.df[i,"trough.zt"])))
}
return(output.selected.genes.df)
}
## Function to generate output table to download
create.downloadable.output.table <- function(input.gene.df,alias,tfs.names)
{
output.selected.genes.df <- data.frame(matrix(nrow=nrow(input.gene.df), ncol=6))
colnames(output.selected.genes.df) <- c("AGI ID", "Gene Name", "Gene Description", "Regulators","Expression Peak Time","Expression Trough Time")
output.selected.genes.df$`Gene Description` <- input.gene.df$description
for(i in 1:nrow(output.selected.genes.df))
{
output.selected.genes.df[i,1] <- input.gene.df[i,1]
output.selected.genes.df[i,2] <- alias[input.gene.df[i,1]]
output.selected.genes.df[i,4] <- paste(tfs.names[which(input.gene.df[i,tfs.names] == 1)],collapse=", ")
output.selected.genes.df[i,5] <-paste0("ZT",substr(input.gene.df[i,"peak.zt"],start=5,stop=nchar(input.gene.df[i,"peak.zt"])))
output.selected.genes.df[i,6] <-paste0("ZT",substr(input.gene.df[i,"trough.zt"],start=7,stop=nchar(input.gene.df[i,"trough.zt"])))
}
return(output.selected.genes.df)
}
## Auxiliary function to compute enrichments for GO table
compute.enrichments <- function(gene.ratios, bg.ratios)
{
gene.ratios.eval <- sapply(parse(text=gene.ratios),FUN = eval)
bg.ratios.eval <- sapply(parse(text=bg.ratios),FUN = eval)
enrichments <- round(x=gene.ratios.eval/bg.ratios.eval,digits = 2)
enrichments.text <- paste(enrichments, " (", gene.ratios, "; ", bg.ratios, ")",sep="")
return(enrichments.text)
}
#GO links and tair link functions
go.link <- function(go.term)
{
link <- paste0("http://amigo.geneontology.org/amigo/term/", go.term)
complete.link <- paste(c("<a href=\"",
link,
"\" target=\"_blank\">",
go.term, "</a>"),
collapse = "")
return(complete.link)
}
gene.link.function <- function(gene.name)
{
tair.link <- paste(c("https://www.arabidopsis.org/servlets/TairObject?name=",
gene.name,
"&type=locus"),collapse="")
gene.link <- paste(c("<a href=\"",
tair.link,
"\" target=\"_blank\">",
gene.name, "</a>"),
collapse="")
return(gene.link)
}
## KEGG pathway link
kegg.pathway.link <- function(kegg.pathway)
{
link <- paste0("https://www.genome.jp/kegg-bin/show_pathway?",kegg.pathway)
complete.link <- paste(c("<a href=\"",
link,
"\" target=\"_blank\">",
kegg.pathway, "</a>"),
collapse = "")
return(complete.link)
}
## KEGG module link
kegg.module.link <- function(kegg.module)
{
link <- paste0("https://www.genome.jp/kegg-bin/show_module?",kegg.module)
complete.link <- paste(c("<a href=\"",
link,
"\" target=\"_blank\">",
kegg.module, "</a>"),
collapse = "")
return(complete.link)
}
## TFBS jaspar link
tfbs.link <- function(motif.id)
{
link <- paste0("http://jaspar.genereg.net/matrix/",motif.id)
complete.link <- paste(c("<a href=\"",
link,
"\" target=\"_blank\">",
motif.id, "</a>"),
collapse = "")
return(complete.link)
}
## Red gradient for animation
red.gradient <- colorRampPalette(c("red", "white"))
current.red.gradient <- c(red.gradient(5),rep("#FFFFFF",15))
## Sanity checks
validate(
need(input$selected.multiple.tfs, "Please select a set of transcription factors")
)
## Determine targets of selected TFs
selected.tfs.with.zts <- str_replace(string = input$selected.multiple.tfs,pattern = " ",replacement = "_")
selected.only.tfs <- sapply(X = strsplit(x = input$selected.multiple.tfs,split = " "), FUN = get.first)
selected.tfs.adj <- (network.data[,selected.tfs.with.zts] != 0)
if(length(selected.tfs.with.zts) > 1)
{
gene.selection <- rowSums(selected.tfs.adj) == length(selected.tfs.with.zts)
} else if (length(selected.tfs.with.zts) == 1)
{
gene.selection <- as.vector(selected.tfs.adj)
}
## Determine targets with the specified expression profile
selected.genes.df <- network.data[gene.selection,]
if(input$peak != "any" && input$trough != "any")
{
selected.genes.df <- subset(selected.genes.df, (peak.zt == input$peak & trough.zt == input$trough))
} else if(input$peak == "any" && input$trough != "any")
{
selected.genes.df <- subset(selected.genes.df, trough.zt == input$trough)
} else if(input$peak != "any" && input$trough == "any")
{
selected.genes.df <- subset(selected.genes.df, peak.zt == input$peak)
}
## Set the background to perform TFBS enrichment analysis depending on the user selection
if (input$tfbs_background == "allgenome")
{
tfbs.universe <- 33323
} else
{
tfbs.universe <- 5778
}
file.precomputed <- paste0(c("precomputed_",input$up_promoter,"_",
input$down_promoter, "_",
input$score, "_",tfbs.universe,".tsv"),collapse="")
## Load file with precomputed results (background) and compute m and n
precomputed.result <- read.table(file=paste0("data/precomputed_results_tfbs/",file.precomputed),header = T)
m <- colSums(precomputed.result > 0)
n <- nrow(precomputed.result) - m
precomputed.result
file.precomputed
## Load file with precomputed results (background) and compute m and n
precomputed.result <- read.table(file=paste0("data/precomputed_results_tfbs/",file.precomputed),header = T)
m <- colSums(precomputed.result > 0)
n <- nrow(precomputed.result) - m
## Compute selection size (k) and number of ocurrences (x).
# target.genes <- read.table(file = "peak_ZT0_trough_ZT12.txt",as.is = T)[[1]]
target.genes <- intersect(rownames(precomputed.result),selected.genes.df$names)
target.genes
gene.selection
selected.genes.df
runApp()
input$selected.multiple.tfs
## Determine targets of selected TFs
selected.tfs.with.zts <- str_replace(string = input$selected.multiple.tfs,pattern = " ",replacement = "_")
selected.tfs.with.zts
selected.only.tfs <- sapply(X = strsplit(x = input$selected.multiple.tfs,split = " "), FUN = get.first)
selected.tfs.adj <- (network.data[,selected.tfs.with.zts] != 0)
selected.only.tfs
selected.tfs.adj
gene.selection <- rowSums(selected.tfs.adj) == length(selected.tfs.with.zts)
gene.selection
length(selected.tfs.with.zts)
rowSums(selected.tfs.adj)
network.data[,selected.tfs.with.zts] != 0
shiny::runApp()
shiny::runApp()
install.packages("shinythemes")
runApp()
shiny::runApp()
shiny::runApp()
runApp()
